

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Graphics &mdash; pySFML2 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="pySFML2 1.0 documentation" href="../index.html" />
    <link rel="up" title="Documentation" href="../documentation.html" />
    <link rel="next" title="Audio" href="audio.html" />
    <link rel="prev" title="Window" href="window.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="audio.html" title="Audio"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="window.html" title="Window"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">pySFML2 1.0 documentation</a> &raquo;</li>
          <li><a href="../documentation.html" accesskey="U">Documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-sf">
<span id="graphics"></span><h1>Graphics<a class="headerlink" href="#module-sf" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="sf.Color">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">Color</tt><a class="headerlink" href="#sf.Color" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Utility class for manpulating RGBA colors.</p>
<p><a class="reference internal" href="#sf.Color" title="sf.Color"><tt class="xref py py-class docutils literal"><span class="pre">sf.Color</span></tt></a> is a simple color class composed of 4
components:</p>
<blockquote>
<div><ul class="simple">
<li>Red,</li>
<li>Green</li>
<li>Blue</li>
<li>Alpha (opacity)</li>
</ul>
</div></blockquote>
<p>Each component is a property, an unsigned integer in the range
[0, 255]. Thus, colors can be constructed and manipulated very
easily:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">c1</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c"># red</span>
<span class="n">c1</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                <span class="c"># make it black</span>
<span class="n">c1</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>              <span class="c"># make it dark blue</span>
</pre></div>
</div>
<p>The fourth component of colors, named &#8220;alpha&#8221;, represents the
opacity of the color. A color with an alpha value of 255 will be
fully opaque, while an alpha value of 0 will make a color fully
transparent, whatever the value of the other components is.</p>
<p>The most common colors are already defined.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">black</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="o">.</span><span class="n">BLACK</span>
<span class="n">white</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="o">.</span><span class="n">WHITE</span>
<span class="n">red</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="o">.</span><span class="n">RED</span>
<span class="n">green</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="o">.</span><span class="n">GREEN</span>
<span class="n">blue</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="o">.</span><span class="n">BLUE</span>
<span class="n">yellow</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="o">.</span><span class="n">YELLOW</span>
<span class="n">magenta</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="o">.</span><span class="n">MAGENTA</span>
<span class="n">cyan</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="o">.</span><span class="n">CYAN</span>
<span class="n">transparent</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="o">.</span><span class="n">TRANSPARENT</span>
</pre></div>
</div>
<p>Colors can also be added and modulated (multiplied) using the
overloaded operators + and <a href="#id1"><span class="problematic" id="id2">*</span></a>.</p>
</div></blockquote>
<dl class="method">
<dt id="sf.Color.Color">
<tt class="descname">Color</tt><big>(</big><em>r</em>, <em>g</em>, <em>b</em><span class="optional">[</span>, <em>a=255</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.Color.Color" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the color from its 4 RGBA components.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>r</strong> (<em>integer</em>) &#8211; Red component (in the range [0, 255])</li>
<li><strong>g</strong> (<em>integer</em>) &#8211; Green component (in the range [0, 255])</li>
<li><strong>b</strong> (<em>integer</em>) &#8211; Blue component (in the range [0, 255])</li>
<li><strong>a</strong> (<em>integer</em>) &#8211; Alpha (opacity) component (in the range [0, 255])</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="data">
<dt id="sf.Color.BLACK">
<tt class="descname">BLACK</tt><a class="headerlink" href="#sf.Color.BLACK" title="Permalink to this definition">¶</a></dt>
<dd><p>Black predefined color.</p>
</dd></dl>

<dl class="data">
<dt id="sf.Color.WHITE">
<tt class="descname">WHITE</tt><a class="headerlink" href="#sf.Color.WHITE" title="Permalink to this definition">¶</a></dt>
<dd><p>White predefined color.</p>
</dd></dl>

<dl class="data">
<dt id="sf.Color.RED">
<tt class="descname">RED</tt><a class="headerlink" href="#sf.Color.RED" title="Permalink to this definition">¶</a></dt>
<dd><p>Red predefined color.</p>
</dd></dl>

<dl class="data">
<dt id="sf.Color.GREEN">
<tt class="descname">GREEN</tt><a class="headerlink" href="#sf.Color.GREEN" title="Permalink to this definition">¶</a></dt>
<dd><p>Green predefined color.</p>
</dd></dl>

<dl class="data">
<dt id="sf.Color.BLUE">
<tt class="descname">BLUE</tt><a class="headerlink" href="#sf.Color.BLUE" title="Permalink to this definition">¶</a></dt>
<dd><p>Blue predefined color.</p>
</dd></dl>

<dl class="data">
<dt id="sf.Color.YELLOW">
<tt class="descname">YELLOW</tt><a class="headerlink" href="#sf.Color.YELLOW" title="Permalink to this definition">¶</a></dt>
<dd><p>Yellow predefined color.</p>
</dd></dl>

<dl class="data">
<dt id="sf.Color.MAGENTA">
<tt class="descname">MAGENTA</tt><a class="headerlink" href="#sf.Color.MAGENTA" title="Permalink to this definition">¶</a></dt>
<dd><p>Magenta predefined color.</p>
</dd></dl>

<dl class="data">
<dt id="sf.Color.CYAN">
<tt class="descname">CYAN</tt><a class="headerlink" href="#sf.Color.CYAN" title="Permalink to this definition">¶</a></dt>
<dd><p>Cyan predefined color.</p>
</dd></dl>

<dl class="data">
<dt id="sf.Color.TRANSPARENT">
<tt class="descname">TRANSPARENT</tt><a class="headerlink" href="#sf.Color.TRANSPARENT" title="Permalink to this definition">¶</a></dt>
<dd><p>Transparent (black) predefined color.</p>
</dd></dl>

<dl class="attribute">
<dt id="sf.Color.r">
<tt class="descname">r</tt><a class="headerlink" href="#sf.Color.r" title="Permalink to this definition">¶</a></dt>
<dd><p>Red component.</p>
</dd></dl>

<dl class="attribute">
<dt id="sf.Color.g">
<tt class="descname">g</tt><a class="headerlink" href="#sf.Color.g" title="Permalink to this definition">¶</a></dt>
<dd><p>Green component.</p>
</dd></dl>

<dl class="attribute">
<dt id="sf.Color.b">
<tt class="descname">b</tt><a class="headerlink" href="#sf.Color.b" title="Permalink to this definition">¶</a></dt>
<dd><p>Blue component.</p>
</dd></dl>

<dl class="attribute">
<dt id="sf.Color.a">
<tt class="descname">a</tt><a class="headerlink" href="#sf.Color.a" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha (opacity) component.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.Transform">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">Transform</tt><a class="headerlink" href="#sf.Transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a 3x3 transform matrix.</p>
<p>A <a class="reference internal" href="#sf.Transform" title="sf.Transform"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transform</span></tt></a> specifies how to translate, rotate, scale,
shear, project, whatever things.</p>
<p>In mathematical terms, it defines how to transform a coordinate
system into another.</p>
<p>For example, if you apply a rotation transform to a sprite, the
result will be a rotated sprite. And anything that is transformed
by this rotation transform will be rotated the same way, according
to its initial position.</p>
<p>Transforms are typically used for drawing. But they can also be
used for any computation that requires to transform points between
the local and global coordinate systems of an entity (like
collision detection).</p>
<p>Usage exampe:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># define a translation transform</span>
<span class="n">translation</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Transform</span><span class="p">()</span>
<span class="n">translation</span><span class="o">.</span><span class="n">translate</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>

<span class="c"># define a rotation transform</span>
<span class="n">rotation</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Transform</span><span class="p">()</span>
<span class="n">rotation</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>

<span class="c"># combine them</span>
<span class="n">transform</span> <span class="o">=</span> <span class="n">translation</span> <span class="o">*</span> <span class="n">rotation</span>

<span class="c"># use the result to transform stuff...</span>
<span class="n">point</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">transform_point</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="n">rectangle</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">transform_rectangle</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)))</span>
</pre></div>
</div>
<dl class="classmethod">
<dt id="sf.Transform.from_values">
<em class="property">classmethod </em><tt class="descname">from_values</tt><big>(</big><em>a00</em>, <em>a01</em>, <em>a02</em>, <em>a10</em>, <em>a11</em>, <em>a12</em>, <em>a20</em>, <em>a21</em>, <em>a22</em><big>)</big><a class="headerlink" href="#sf.Transform.from_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a transform from a 3x3 matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a00</strong> (<em>float</em>) &#8211; Element (0, 0) of the matrix</li>
<li><strong>a01</strong> (<em>float</em>) &#8211; Element (0, 1) of the matrix</li>
<li><strong>a02</strong> (<em>float</em>) &#8211; Element (0, 2) of the matrix</li>
<li><strong>a10</strong> (<em>float</em>) &#8211; Element (1, 0) of the matrix</li>
<li><strong>a11</strong> (<em>float</em>) &#8211; Element (1, 1) of the matrix</li>
<li><strong>a12</strong> (<em>float</em>) &#8211; Element (1, 2) of the matrix</li>
<li><strong>a20</strong> (<em>float</em>) &#8211; Element (2, 0) of the matrix</li>
<li><strong>a21</strong> (<em>float</em>) &#8211; Element (2, 1) of the matrix</li>
<li><strong>a22</strong> (<em>float</em>) &#8211; Element (2, 2) of the matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#sf.Transform" title="sf.Transform"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transform</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Transform.matrix">
<tt class="descname">matrix</tt><a class="headerlink" href="#sf.Transform.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the transform as a 4x4 matrix.</p>
<p>This function returns a pointer to an array of 16 floats
containing the transform elements as a 4x4 matrix, which is
directly compatible with OpenGL functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body">long</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Transform.inverse">
<tt class="descname">inverse</tt><a class="headerlink" href="#sf.Transform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse of the transform.</p>
<p>If the inverse cannot be computed, an identity transform is
returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body"><a class="reference internal" href="#sf.Transform" title="sf.Transform"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transform</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Transform.transform_point">
<tt class="descname">transform_point</tt><big>(</big><em>point</em><big>)</big><a class="headerlink" href="#sf.Transform.transform_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a 2D point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>point</strong> (<a class="reference internal" href="system.html#sf.Position" title="sf.Position"><tt class="xref py py-class docutils literal"><span class="pre">sf.Position</span></tt></a> or tuple) &#8211; Point to transform</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Transformed point</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Position" title="sf.Position"><tt class="xref py py-class docutils literal"><span class="pre">sf.Position</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Transform.transform_rectangle">
<tt class="descname">transform_rectangle</tt><big>(</big><em>rectangle</em><big>)</big><a class="headerlink" href="#sf.Transform.transform_rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a rectangle.</p>
<p>Since SFML doesn&#8217;t provide support for oriented rectangles, the
result of this function is always an axis-aligned rectangle.
Which means that if the transform contains a rotation, the
bounding rectangle of the transformed rectangle is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rectangle</strong> (<a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a> or tuple) &#8211; Rectangle to transform</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Transformed rectangle</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Transform.combine">
<tt class="descname">combine</tt><big>(</big><em>transform</em><big>)</big><a class="headerlink" href="#sf.Transform.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the current transform with another one.</p>
<p>The result is a transform that is equivalent to applying this
followed by transform. Mathematically, it is equivalent to a
matrix multiplication.</p>
<p>This function returns a reference <em>self</em>, so that calls can be
chained.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>transform</strong> (<a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><em>sf.Rectangle</em></a>) &#8211; Transform to combine with this transform</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Return itself</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Transform" title="sf.Transform"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transform</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Transform.translate">
<tt class="descname">translate</tt><big>(</big><em>offset</em><big>)</big><a class="headerlink" href="#sf.Transform.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the current transform with a translation.</p>
<p>This function returns a reference to <em>self</em>, so that calls can be
chained.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">transform</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Transform</span><span class="p">()</span>
<span class="n">transform</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">Position</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">))</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>offset</strong> (<a class="reference internal" href="system.html#sf.Position" title="sf.Position"><tt class="xref py py-class docutils literal"><span class="pre">sf.Position</span></tt></a> or tuple) &#8211; Translation offset to apply</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Return itself</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Transform" title="sf.Transform"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transform</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Transform.rotate">
<tt class="descname">rotate</tt><big>(</big><em>angle</em><span class="optional">[</span>, <em>center</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.Transform.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the current transform with a rotation.</p>
<p>The center of rotation is provided for convenience as a second
argument, so that you can build rotations around arbitrary points
more easily (and efficiently) than the usual
translate(-center).rotate(angle).translate(center).</p>
<p>This function returns a reference to <em>self</em>, so that calls can be
chained.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">transform</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Transform</span><span class="p">()</span>
<span class="n">transform</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mi">90</span><span class="p">,</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">translate</span><span class="p">((</span><span class="mi">50</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>angle</strong> (<em>float</em>) &#8211; Rotation angle, in degrees</li>
<li><strong>center</strong> (<a class="reference internal" href="system.html#sf.Position" title="sf.Position"><tt class="xref py py-class docutils literal"><span class="pre">sf.Position</span></tt></a> or tuple) &#8211; Center of rotation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Return itself</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#sf.Transform" title="sf.Transform"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transform</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Transform.scale">
<tt class="descname">scale</tt><big>(</big><em>factor</em><span class="optional">[</span>, <em>center</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.Transform.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the current transform with a scaling.</p>
<p>The center of scaling is provided for convenience as a second
argument, so that you can build scaling around arbitrary points
more easily (and efficiently) than the usual
translate(-center).scale(factors).translate(center).</p>
<p>This function returns a reference to <em>self</em>, so that calls can be
chained.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">transform</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Transform</span><span class="p">()</span>
<span class="n">transform</span><span class="o">.</span><span class="n">scale</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>factor</strong> (<a class="reference internal" href="system.html#sf.Position" title="sf.Position"><tt class="xref py py-class docutils literal"><span class="pre">sf.Position</span></tt></a> or tuple) &#8211; Scaling factors</li>
<li><strong>center</strong> (<a class="reference internal" href="system.html#sf.Position" title="sf.Position"><tt class="xref py py-class docutils literal"><span class="pre">sf.Position</span></tt></a> or tuple) &#8211; Center of scaling</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Return itself</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#sf.Transform" title="sf.Transform"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transform</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.Pixels">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">Pixels</tt><a class="headerlink" href="#sf.Pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility class to manipulate pixels, more precisely, an array of
unsigned char that represents an image.</p>
<p>This could have been handled with the built-in type &#8220;bytes&#8221; for
python3 or a simple string coded on 8-bits for python2 but as an
image has two dimensions, it has to tell its width (and its height)
too.</p>
<p>Usage examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">image</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">load_from_file</span><span class="p">(</span><span class="s">&quot;icon.png&quot;</span><span class="p">)</span>
<span class="n">window</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Window</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">VideoMode</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="s">&quot;pySFML&quot;</span><span class="p">)</span>

<span class="n">window</span><span class="o">.</span><span class="n">icon</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">pixels</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">86</span><span class="p">,</span> <span class="mi">217</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">size</span>
<span class="n">pixels</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">pixels</span>

<span class="k">assert</span> <span class="n">pixels</span><span class="p">[</span><span class="n">w</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">image</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">r</span>
<span class="k">assert</span> <span class="n">pixels</span><span class="p">[</span><span class="n">w</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">image</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">g</span>
<span class="k">assert</span> <span class="n">pixels</span><span class="p">[</span><span class="n">w</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">image</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">b</span>
<span class="k">assert</span> <span class="n">pixels</span><span class="p">[</span><span class="n">w</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">image</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">a</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sf.Image">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">Image</tt><a class="headerlink" href="#sf.Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for loading, manipulating and saving images.</p>
<p><a class="reference internal" href="#sf.Image" title="sf.Image"><tt class="xref py py-class docutils literal"><span class="pre">sf.Image</span></tt></a> is an abstraction to manipulate images as
bidimensional arrays of pixels.</p>
<p>The class provides functions to load, read, write and save pixels,
as well as many other useful functions.</p>
<p><a class="reference internal" href="#sf.Image" title="sf.Image"><tt class="xref py py-class docutils literal"><span class="pre">sf.Image</span></tt></a> can handle a unique internal representation of
pixels, which is RGBA 32 bits. This means that a pixel must be
composed of 8 bits red, green, blue and alpha channels &#8211; just like
a <a class="reference internal" href="#sf.Color" title="sf.Color"><tt class="xref py py-class docutils literal"><span class="pre">sf.Color</span></tt></a>. All the functions that return an array of
pixels follow this rule, and all parameters that you pass to
<a class="reference internal" href="#sf.Image" title="sf.Image"><tt class="xref py py-class docutils literal"><span class="pre">sf.Image</span></tt></a> functions (such as <tt class="xref py py-func docutils literal"><span class="pre">load_from_pixels()</span></tt>) must
use this representation as well.</p>
<p>A <cite>sf.Image</cite> can be copied, but it is a heavy resource; keep it in
mind!</p>
<p>Usage example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
   <span class="c"># load an image file from a file</span>
   <span class="n">background</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">load_from_file</span><span class="p">(</span><span class="s">&quot;background.jpg&quot;</span><span class="p">)</span>

   <span class="c"># create a 20x20 image filled with black color</span>
   <span class="n">image</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="o">.</span><span class="n">BLACK</span><span class="p">)</span>

<span class="k">except</span> <span class="n">sf</span><span class="o">.</span><span class="n">SFMLException</span><span class="p">:</span>
   <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># copy image1 on image 2 at position(10, 10)</span>
<span class="n">background</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="c"># make the top-left pixel transparent</span>
<span class="n">color</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">color</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>

<span class="c"># save the image to a file</span>
<span class="n">background</span><span class="o">.</span><span class="n">save_to_file</span><span class="p">(</span><span class="s">&quot;result.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="classmethod">
<dt id="sf.Image.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>width, height, color=sf.Color.BLACK]</em><big>)</big><a class="headerlink" href="#sf.Image.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the image and fill it with a unique color.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>width</strong> (<em>integer</em>) &#8211; Width of the image</li>
<li><strong>height</strong> (<em>integer</em>) &#8211; Height of the image</li>
<li><strong>color</strong> (<a class="reference internal" href="#sf.Color" title="sf.Color"><em>sf.Color</em></a>) &#8211; Fill color</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#sf.Image" title="sf.Image"><tt class="xref py py-class docutils literal"><span class="pre">sf.Image</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="sf.Image.create_from_pixels">
<em class="property">classmethod </em><tt class="descname">create_from_pixels</tt><big>(</big><em>pixels</em><big>)</big><a class="headerlink" href="#sf.Image.create_from_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the image from an array of pixels wrapped around
<a class="reference internal" href="#sf.Pixels" title="sf.Pixels"><tt class="xref py py-class docutils literal"><span class="pre">sf.Pixels</span></tt></a>. This function fails without raising error if
pixels are invalid. On the other hand, it raises one if <em>pixels</em>
points on <em>NULL</em>?</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raise :</th><td class="field-body"><a class="reference internal" href="system.html#sf.SFMLException" title="sf.SFMLException"><tt class="xref py py-exc docutils literal"><span class="pre">sf.SFMLException</span></tt></a> - If <em>pixels</em> is empty.</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pixels</strong> (<a class="reference internal" href="#sf.Pixels" title="sf.Pixels"><em>sf.Pixels</em></a>) &#8211; Array of pixels to copy to the image</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Image" title="sf.Image"><tt class="xref py py-class docutils literal"><span class="pre">sf.Image</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="sf.Image.load_from_file">
<em class="property">classmethod </em><tt class="descname">load_from_file</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#sf.Image.load_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the image from a file on disk.</p>
<p>The supported image formats are bmp, png, tga, jpg, gif, psd, hdr
and pic. Some format options are not supported, like progressive
jpeg. If this function fails, it raises an exception.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raise :</th><td class="field-body"><a class="reference internal" href="system.html#sf.SFMLException" title="sf.SFMLException"><tt class="xref py py-exc docutils literal"><span class="pre">sf.SFMLException</span></tt></a> - If it fails</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; Path of the image file to load</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Image" title="sf.Image"><tt class="xref py py-class docutils literal"><span class="pre">sf.Image</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="sf.Image.load_from_memory">
<em class="property">classmethod </em><tt class="descname">load_from_memory</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#sf.Image.load_from_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the image from a file in memory.</p>
<p>The supported image formats are bmp, png, tga, jpg, gif, psd, hdr
and pic. Some format options are not supported, like progressive
jpeg. If this function fails, it raises an exception.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raise :</th><td class="field-body"><a class="reference internal" href="system.html#sf.SFMLException" title="sf.SFMLException"><tt class="xref py py-exc docutils literal"><span class="pre">sf.SFMLException</span></tt></a> - If it fails</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>bytes</em>) &#8211; The data to load, in bytes</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Image" title="sf.Image"><tt class="xref py py-class docutils literal"><span class="pre">sf.Image</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="sf.Image.save_to_file">
<em class="property">classmethod </em><tt class="descname">save_to_file</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#sf.Image.save_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the image to a file on disk.</p>
<p>The format of the image is automatically deduced from the
extension. The supported image formats are bmp, png, tga and jpg.
The destination file is overwritten if it already exists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raise :</th><td class="field-body"><a class="reference internal" href="system.html#sf.SFMLException" title="sf.SFMLException"><tt class="xref py py-exc docutils literal"><span class="pre">sf.SFMLException</span></tt></a> - If the image is empty</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; Path of the file to save</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Image.size">
<tt class="descname">size</tt><a class="headerlink" href="#sf.Image.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of the image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body"><a class="reference internal" href="system.html#sf.Size" title="sf.Size"><tt class="xref py py-class docutils literal"><span class="pre">sf.Size</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Image.width">
<tt class="descname">width</tt><a class="headerlink" href="#sf.Image.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the width of the image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Image.height">
<tt class="descname">height</tt><a class="headerlink" href="#sf.Image.height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the width of the image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body">height</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Image.create_mask_from_color">
<tt class="descname">create_mask_from_color</tt><big>(</big><em>color</em><span class="optional">[</span>, <em>alpha=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.Image.create_mask_from_color" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a transparency mask from a specified color-key.</p>
<p>This function sets the alpha value of every pixel matching the
given color to alpha (0 by default), so that they become
transparent.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>color</strong> (<a class="reference internal" href="#sf.Color" title="sf.Color"><em>sf.Color</em></a>) &#8211; Color to make transparent</li>
<li><strong>alpha</strong> (<em>integer</em>) &#8211; Alpha value to assign to transparent pixels</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Image.blit">
<tt class="descname">blit</tt><big>(</big><em>source</em>, <em>dest</em><span class="optional">[</span>, <em>source_rect=(0</em>, <em>0</em>, <em>0</em>, <em>0)</em><span class="optional">[</span>, <em>apply_alpha=False</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.Image.blit" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy pixels from another image onto this one.</p>
<p>This function does a slow pixel copy and should not be used
intensively. It can be used to prepare a complex static image
from several others, but if you need this kind of feature in
real-time you&#8217;d better use <tt class="xref py py-class docutils literal"><span class="pre">sf.RenderTexture</span></tt>.</p>
<p>If <em>source_rect</em> is empty, the whole image is copied. If
<em>apply_alpha</em> is set to true, the transparency of source pixels is
applied. If it is false, the pixels are copied unchanged with
their alpha value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source</strong> (<a class="reference internal" href="#sf.Image" title="sf.Image"><em>sf.Image</em></a>) &#8211; Source image to copy</li>
<li><strong>dest</strong> (<a class="reference internal" href="system.html#sf.Position" title="sf.Position"><tt class="xref py py-class docutils literal"><span class="pre">sf.Position</span></tt></a> or None) &#8211; Coordinate of the destination position</li>
<li><strong>source_rect</strong> (<a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a> or tuple) &#8211; Sub-rectangle of the source image to copy</li>
<li><strong>apply_alpha</strong> (<em>bool</em>) &#8211; Should the copy take in account the source transparency ?</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Image.pixels">
<tt class="descname">pixels</tt><a class="headerlink" href="#sf.Image.pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a read-only pointer to the array of pixels. This pointer is
wrapped around <a class="reference internal" href="#sf.Pixels" title="sf.Pixels"><tt class="xref py py-class docutils literal"><span class="pre">sf.Pixels</span></tt></a>.</p>
<p>The returned value points to an array of RGBA pixels made of 8
bits integers components. The size of the array is <a class="reference internal" href="#sf.Image.width" title="sf.Image.width"><tt class="xref py py-attr docutils literal"><span class="pre">width</span></tt></a>
* <a class="reference internal" href="#sf.Image.height" title="sf.Image.height"><tt class="xref py py-attr docutils literal"><span class="pre">height</span></tt></a> * 4.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The returned object may become invalid if you modify the
image, so you should never store it for too long. If the image
is empty, None is returned.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body"><a class="reference internal" href="#sf.Pixels" title="sf.Pixels"><tt class="xref py py-class docutils literal"><span class="pre">sf.Pixels</span></tt></a> or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Image.flip_horizontally">
<tt class="descname">flip_horizontally</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Image.flip_horizontally" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip the image horizontally (left &lt;-&gt; right)</p>
</dd></dl>

<dl class="method">
<dt id="sf.Image.flip_vertically">
<tt class="descname">flip_vertically</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Image.flip_vertically" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip the image vertically (top &lt;-&gt; bottom)</p>
</dd></dl>

<dl class="method">
<dt id="sf.Image.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Image.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Python always works by reference, unless you explicitly ask for
a copy, that&#8217;s why this method is provided.</p>
</dd></dl>

<dl class="method">
<dt id="sf.Image.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Image.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a pixel from the image.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>    <span class="c"># create tuple implicitly</span>
<span class="k">print</span><span class="p">(</span><span class="n">image</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>  <span class="c"># create tuple explicitly</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sf.Image.__setitem__">
<tt class="descname">__setitem__</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Image.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a pixel of the image.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>  <span class="c"># create tuple implicitly</span>
<span class="n">image</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>  <span class="c"># create tuple explicitly</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.Texture">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">Texture</tt><a class="headerlink" href="#sf.Texture" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#sf.Image" title="sf.Image"><tt class="xref py py-class docutils literal"><span class="pre">Image</span></tt></a> living on the graphics card that can be used for
drawing.</p>
<p><a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a> stores pixels that can be drawn, with a sprite
for example.</p>
<p>A texture lives in the graphics card memory, therefore it is very
fast to draw a texture to a render target, or copy a render target
to a texture (the graphics card can access both directly).</p>
<p>Being stored in the graphics card memory has some drawbacks. A
texture cannot be manipulated as freely as a <a class="reference internal" href="#sf.Image" title="sf.Image"><tt class="xref py py-class docutils literal"><span class="pre">sf.Image</span></tt></a>, you
need to prepare the pixels first and then upload them to the texture
in a single operation (see <a class="reference internal" href="#sf.Texture.update" title="sf.Texture.update"><tt class="xref py py-func docutils literal"><span class="pre">Texture.update()</span></tt></a>).</p>
<p><a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a> makes it easy to convert from/to
<a class="reference internal" href="#sf.Image" title="sf.Image"><tt class="xref py py-class docutils literal"><span class="pre">sf.Image</span></tt></a>, but keep in mind that these calls require
transfers between the graphics card and the central memory,
therefore they are slow operations.</p>
<p>A texture can be loaded from an image, but also directly from a file
or a memory. The necessary shortcuts are defined so that you don&#8217;t
need an image first for the most common cases. However, if you want
to perform some modifications on the pixels before creating the
final texture, you can load your file to a <a class="reference internal" href="#sf.Image" title="sf.Image"><tt class="xref py py-class docutils literal"><span class="pre">sf.Image</span></tt></a>, do
whatever you need with the pixels, and then call
<a class="reference internal" href="#sf.Texture.load_from_image" title="sf.Texture.load_from_image"><tt class="xref py py-func docutils literal"><span class="pre">Texture.load_from_image()</span></tt></a>.</p>
<p>Since they live in the graphics card memory, the pixels of a texture
cannot be accessed without a slow copy first. And they cannot be
accessed individually. Therefore, if you need to read the texture&#8217;s
pixels (like for pixel-perfect collisions), it is recommended to
store the collision information separately, for example in an array
of booleans.</p>
<p>Like <a class="reference internal" href="#sf.Image" title="sf.Image"><tt class="xref py py-class docutils literal"><span class="pre">sf.Image</span></tt></a>, <a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a> can handle a unique
internal representation of pixels, which is RGBA 32 bits. This means
that a pixel must be composed of 8 bits red, green, blue and alpha
channels &#8211; just like a <a class="reference internal" href="#sf.Color" title="sf.Color"><tt class="xref py py-class docutils literal"><span class="pre">sf.Color</span></tt></a>.</p>
<p>Usage example:</p>
<p>This first example shows the most common use of sf.Texture: drawing a sprite</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#load a texture from a file</span>
<span class="k">try</span><span class="p">:</span>
   <span class="n">texture</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Texture</span><span class="o">.</span><span class="n">load_from_file</span><span class="p">(</span><span class="s">&quot;texture.png&quot;</span><span class="p">)</span>

<span class="k">except</span> <span class="n">sf</span><span class="o">.</span><span class="n">SFMLException</span><span class="p">:</span> <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># assign it to a sprite</span>
<span class="n">sprite</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Sprite</span><span class="p">()</span>
<span class="n">sprite</span><span class="o">.</span><span class="n">texture</span> <span class="o">=</span> <span class="n">texture</span>

<span class="c"># draw the textured sprite</span>
<span class="n">window</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">sprite</span><span class="p">);</span>
</pre></div>
</div>
<p>This second example shows another common use of sf.Texture: streaming real-time data, like video frames</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># create an empty texture</span>
<span class="n">texture</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Texture</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>

<span class="c"># create a sprite that will display the texture</span>
<span class="n">sprite</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Sprite</span><span class="p">(</span><span class="n">texture</span><span class="p">)</span>

<span class="k">while</span> <span class="n">loop</span><span class="p">:</span> <span class="c"># the main loop</span>
   <span class="c"># ...</span>

   <span class="c"># get a fresh chunk of pixels (the next frame of a movie, for example)</span>
   <span class="n">pixels</span> <span class="o">=</span> <span class="n">get_pixels_function</span><span class="p">()</span>

   <span class="c"># update the texture</span>
   <span class="n">texture</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span>
   <span class="c"># or use update_from_pixels (faster)</span>
   <span class="n">texture</span><span class="o">.</span><span class="n">update_from_pixels</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span>

   <span class="c"># draw it</span>
   <span class="n">window</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
   <span class="c"># ...</span>
</pre></div>
</div>
<dl class="method">
<dt id="sf.Texture.Texture">
<tt class="descname">Texture</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Texture.Texture" title="Permalink to this definition">¶</a></dt>
<dd><p>The default constructor is not meant to be called. It will raise
<tt class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></tt> with a message telling you that you
must use a specific constructor.</p>
<p>Those specific constructors are: <a class="reference internal" href="#sf.Texture.create" title="sf.Texture.create"><tt class="xref py py-func docutils literal"><span class="pre">create()</span></tt></a>,
<a class="reference internal" href="#sf.Texture.load_from_file" title="sf.Texture.load_from_file"><tt class="xref py py-func docutils literal"><span class="pre">load_from_file()</span></tt></a>, <a class="reference internal" href="#sf.Texture.load_from_memory" title="sf.Texture.load_from_memory"><tt class="xref py py-func docutils literal"><span class="pre">load_from_memory()</span></tt></a>,
<a class="reference internal" href="#sf.Texture.load_from_image" title="sf.Texture.load_from_image"><tt class="xref py py-func docutils literal"><span class="pre">load_from_image()</span></tt></a>.</p>
</dd></dl>

<dl class="data">
<dt id="sf.Texture.NORMALIZED">
<tt class="descname">NORMALIZED</tt><a class="headerlink" href="#sf.Texture.NORMALIZED" title="Permalink to this definition">¶</a></dt>
<dd><p>Texture coordinates in range [0 .. 1].</p>
</dd></dl>

<dl class="data">
<dt id="sf.Texture.PIXELS">
<tt class="descname">PIXELS</tt><a class="headerlink" href="#sf.Texture.PIXELS" title="Permalink to this definition">¶</a></dt>
<dd><p>Texture coordinates in range [0 .. size].</p>
</dd></dl>

<dl class="classmethod">
<dt id="sf.Texture.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>width</em>, <em>height</em><big>)</big><a class="headerlink" href="#sf.Texture.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a texture.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>width</strong> (<em>integer</em>) &#8211; Width of the texture</li>
<li><strong>height</strong> (<em>integer</em>) &#8211; Height of the texture</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="sf.Texture.load_from_file">
<em class="property">classmethod </em><tt class="descname">load_from_file</tt><big>(</big><em>filename</em><span class="optional">[</span>, <em>area=(0</em>, <em>0</em>, <em>0</em>, <em>0)</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.Texture.load_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the texture from a file on disk.</p>
<p>This function is a shortcut for the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">image</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">load_from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="n">texture</span><span class="o">.</span><span class="n">load_from_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">area</span><span class="p">)</span>
</pre></div>
</div>
<p>The area argument can be used to load only a sub-rectangle of the
whole image. If you want the entire image then leave the default
value (which is an empty <a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a>). If the area
rectangle crosses the bounds of the image, it is adjusted to fit
the image size.</p>
<p>The maximum size for a texture depends on the graphics driver and
can be retrieved with the <a class="reference internal" href="#sf.Texture.get_maximum_size" title="sf.Texture.get_maximum_size"><tt class="xref py py-func docutils literal"><span class="pre">get_maximum_size()</span></tt></a> function.</p>
<p>If this function fails, it raises an exception.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raise :</th><td class="field-body"><p class="first"><a class="reference internal" href="system.html#sf.SFMLException" title="sf.SFMLException"><tt class="xref py py-class docutils literal"><span class="pre">sf.SFMLException</span></tt></a> - If it fails</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<em>string</em>) &#8211; Path of the image file to load</li>
<li><strong>area</strong> (<a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a>) &#8211; Area of the image to load</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="sf.Texture.load_from_memory">
<em class="property">classmethod </em><tt class="descname">load_from_memory</tt><big>(</big><em>data</em>, <em>area=(0</em>, <em>0</em>, <em>0</em>, <em>0)</em><big>)</big><a class="headerlink" href="#sf.Texture.load_from_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the texture from a file in memory.</p>
<p>This function is a shortcut for the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">image</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">load_from_memory</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">texture</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Texture</span><span class="o">.</span><span class="n">load_from_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">area</span><span class="p">)</span>
</pre></div>
</div>
<p>The area argument can be used to load only a sub-rectangle of the
whole image. If you want the entire image then leave the default
value (which is an empty <a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a>). If the area
rectangle crosses the bounds of the image, it is adjusted to fit
the image size.</p>
<p>The maximum size for a texture depends on the graphics driver and
can be retrieved with the <a class="reference internal" href="#sf.Texture.get_maximum_size" title="sf.Texture.get_maximum_size"><tt class="xref py py-func docutils literal"><span class="pre">get_maximum_size()</span></tt></a> function.</p>
<p>If this function fails, it raises an exception.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raise :</th><td class="field-body"><p class="first"><a class="reference internal" href="system.html#sf.SFMLException" title="sf.SFMLException"><tt class="xref py py-class docutils literal"><span class="pre">sf.SFMLException</span></tt></a> - If it fails</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>bytes</em>) &#8211; Data to load</li>
<li><strong>area</strong> (<a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a>) &#8211; Area of the image to load</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="sf.Texture.load_from_image">
<em class="property">classmethod </em><tt class="descname">load_from_image</tt><big>(</big><em>image</em><span class="optional">[</span>, <em>area=(0</em>, <em>0</em>, <em>0</em>, <em>0)</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.Texture.load_from_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the texture from an image.</p>
<p>The area argument can be used to load only a sub-rectangle of the
whole image. If you want the entire image then leave the default
value (which is an empty <a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a>). If the area
rectangle crosses the bounds of the image, it is adjusted to fit
the image size.</p>
<p>The maximum size for a texture depends on the graphics driver and
can be retrieved with the <a class="reference internal" href="#sf.Texture.get_maximum_size" title="sf.Texture.get_maximum_size"><tt class="xref py py-func docutils literal"><span class="pre">get_maximum_size()</span></tt></a> function.</p>
<p>If this function fails, it raises an error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raise :</th><td class="field-body"><p class="first"><a class="reference internal" href="system.html#sf.SFMLException" title="sf.SFMLException"><tt class="xref py py-class docutils literal"><span class="pre">sf.SFMLException</span></tt></a> - If it fails</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>image</strong> (<a class="reference internal" href="#sf.Image" title="sf.Image"><em>sf.Image</em></a>) &#8211; Image to load into the texture</li>
<li><strong>area</strong> (<a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><em>sf.Rectangle</em></a>) &#8211; Area of the image to load</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Texture.size">
<tt class="descname">size</tt><a class="headerlink" href="#sf.Texture.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of the texture.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body"><a class="reference internal" href="system.html#sf.Size" title="sf.Size"><tt class="xref py py-class docutils literal"><span class="pre">sf.Size</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Texture.width">
<tt class="descname">width</tt><a class="headerlink" href="#sf.Texture.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the width of the texture.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Texture.height">
<tt class="descname">height</tt><a class="headerlink" href="#sf.Texture.height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the height of the texture.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Texture.copy_to_image">
<tt class="descname">copy_to_image</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Texture.copy_to_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the texture pixels to an image.</p>
<p>This function performs a slow operation that downloads the
texture&#8217;s pixels from the graphics card and copies them to a new
image, potentially applying transformations to pixels if
necessary (texture may be padded or flipped).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Image containing the texture&#8217;s pixels</td>
</tr>
<tr class="field-even field"><th class="field-name">Type :</th><td class="field-body"><a class="reference internal" href="#sf.Image" title="sf.Image"><tt class="xref py py-class docutils literal"><span class="pre">sf.Image</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Texture.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Texture.update" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Not implemented yet. It will be in the next release.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sf.Texture.update_from_pixels">
<tt class="descname">update_from_pixels</tt><big>(</big><em>pixel</em><span class="optional">[</span>, <em>area</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.Texture.update_from_pixels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sf.Texture.update_from_image">
<tt class="descname">update_from_image</tt><big>(</big><em>image</em><span class="optional">[</span>, <em>position</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.Texture.update_from_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sf.Texture.update_from_window">
<tt class="descname">update_from_window</tt><big>(</big><em>window</em><span class="optional">[</span>, <em>position</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.Texture.update_from_window" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sf.Texture.bind">
<tt class="descname">bind</tt><big>(</big><em>coordinate_type=sf.Texture.NORMALIZED</em><big>)</big><a class="headerlink" href="#sf.Texture.bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Activate the texture for rendering.</p>
<p>This function is mainly used internally by the SFML rendering
system. However it can be useful when using <a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a>
together with OpenGL code (this function is equivalent to
glBindTexture).</p>
<p>The coordinateType argument controls how texture coordinates will
be interpreted. If <a class="reference internal" href="#sf.Texture.NORMALIZED" title="sf.Texture.NORMALIZED"><tt class="xref py py-const docutils literal"><span class="pre">NORMALIZED</span></tt></a> (the default), they must
be in range [0 .. 1], which is the default way of handling
texture coordinates with OpenGL. If <a class="reference internal" href="#sf.Texture.PIXELS" title="sf.Texture.PIXELS"><tt class="xref py py-const docutils literal"><span class="pre">PIXELS</span></tt></a>, they must be
given in pixels (range [0 .. size]). This mode is used internally
by the graphics classes of SFML, it makes the definition of
texture coordinates more intuitive for the high-level API, users
don&#8217;t need to compute normalized values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coordinate_type</strong> (<a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a>&#8216;s constant) &#8211; Type of texture coordinates to use</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Texture.smooth">
<tt class="descname">smooth</tt><a class="headerlink" href="#sf.Texture.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Get/set the smooth filter.</p>
<p>When the filter is activated, the texture appears smoother so
that pixels are less noticeable. However if you want the texture
to look exactly the same as its source file, you should leave it
disabled. The smooth filter is disabled by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Texture.repeated">
<tt class="descname">repeated</tt><a class="headerlink" href="#sf.Texture.repeated" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable repeating.</p>
<p>Repeating is involved when using texture coordinates outside the
texture rectangle [0, 0, width, height]. In this case, if repeat
mode is enabled, the whole texture will be repeated as many times
as needed to reach the coordinate (for example, if the X texture
coordinate is 3 * width, the texture will be repeated 3 times).
If repeat mode is disabled, the &#8220;extra space&#8221; will instead be
filled with border pixels. Warning: on very old graphics cards,
white pixels may appear when the texture is repeated. With such
cards, repeat mode can be used reliably only if the texture has
power-of-two dimensions (such as 256x128). Repeating is disabled
by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Texture.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Texture.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Python always works by reference, unless you explicitly ask for
a copy, that&#8217;s why this method is provided.</p>
</dd></dl>

<dl class="classmethod">
<dt id="sf.Texture.get_maximum_size">
<em class="property">classmethod </em><tt class="descname">get_maximum_size</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Texture.get_maximum_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the maximum texture size allowed.</p>
<p>This maximum size is defined by the graphics driver. You can
expect a value of 512 pixels for low-end graphics card, and up to
8192 pixels or more for newer hardware.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Maximum size allowed for textures, in pixels</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.Glyph">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">Glyph</tt><a class="headerlink" href="#sf.Glyph" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure describing a glyph.</p>
<p>A glyph is the visual representation of a character.</p>
<p>The <a class="reference internal" href="#sf.Glyph" title="sf.Glyph"><tt class="xref py py-class docutils literal"><span class="pre">sf.Glyph</span></tt></a> structure provides the information needed to
handle the glyph:</p>
<blockquote>
<div><ul class="simple">
<li>its coordinates in the font&#8217;s texture</li>
<li>its bounding rectangle</li>
<li>the offset to apply to get the starting position of the next glyph</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="sf.Glyph.Glyph">
<tt class="descname">Glyph</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Glyph.Glyph" title="Permalink to this definition">¶</a></dt>
<dd><p>Default constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Glyph" title="sf.Glyph"><tt class="xref py py-class docutils literal"><span class="pre">sf.Glyph</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Glyph.advance">
<tt class="descname">advance</tt><a class="headerlink" href="#sf.Glyph.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset to move horizontically to the next character.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Glyph.bounds">
<tt class="descname">bounds</tt><a class="headerlink" href="#sf.Glyph.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Bounding rectangle of the glyph, in coordinates relative to the
baseline.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Glyph.texture_rectangle">
<tt class="descname">texture_rectangle</tt><a class="headerlink" href="#sf.Glyph.texture_rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">Texture</span></tt></a> coordinates of the glyph inside the font&#8217;s
texture.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.Font">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">Font</tt><a class="headerlink" href="#sf.Font" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Class for loading and manipulating character fonts.</p>
<p>Fonts can be loaded from a file or from memory, and supports the
most common types of fonts.</p>
<p>See the <a class="reference internal" href="#sf.Font.load_from_file" title="sf.Font.load_from_file"><tt class="xref py py-func docutils literal"><span class="pre">load_from_file()</span></tt></a> function for the complete list of
supported formats.</p>
<p>Once it is loaded, a <a class="reference internal" href="#sf.Font" title="sf.Font"><tt class="xref py py-class docutils literal"><span class="pre">sf.Font</span></tt></a> instance provides three
types of informations about the font:</p>
<blockquote>
<div><ul class="simple">
<li>Global metrics, such as the line spacing</li>
<li>Per-glyph metrics, such as bounding box or kerning</li>
<li>Pixel representation of glyphs</li>
</ul>
</div></blockquote>
<p>Fonts alone are not very useful: they hold the font data but
cannot make anything useful of it. To do so you need to use the
<a class="reference internal" href="#sf.Text" title="sf.Text"><tt class="xref py py-class docutils literal"><span class="pre">sf.Text</span></tt></a> class, which is able to properly output text
with several options such as character size, style, color,
position, rotation, etc. This separation allows more flexibility
and better performances: indeed a <a class="reference internal" href="#sf.Font" title="sf.Font"><tt class="xref py py-class docutils literal"><span class="pre">sf.Font</span></tt></a> is a heavy
resource, and any operation on it is slow (often too slow for
real-time applications). On the other side, a <a class="reference internal" href="#sf.Text" title="sf.Text"><tt class="xref py py-class docutils literal"><span class="pre">sf.Text</span></tt></a> is
a lightweight object which can combine the glyphs data and
metrics of a <a class="reference internal" href="#sf.Font" title="sf.Font"><tt class="xref py py-class docutils literal"><span class="pre">sf.Font</span></tt></a> to display any text on a render
target. Note that it is also possible to bind several
<a class="reference internal" href="#sf.Text" title="sf.Text"><tt class="xref py py-class docutils literal"><span class="pre">sf.Text</span></tt></a> instances to the same <a class="reference internal" href="#sf.Font" title="sf.Font"><tt class="xref py py-class docutils literal"><span class="pre">sf.Font</span></tt></a>.</p>
<p>It is important to note that the <a class="reference internal" href="#sf.Text" title="sf.Text"><tt class="xref py py-class docutils literal"><span class="pre">sf.Text</span></tt></a> instance
doesn&#8217;t copy the font that it uses, it only keeps a reference to
it. Thus, a <a class="reference internal" href="#sf.Font" title="sf.Font"><tt class="xref py py-class docutils literal"><span class="pre">sf.Font</span></tt></a> must not be destructed while it is
used by a <a class="reference internal" href="#sf.Text" title="sf.Text"><tt class="xref py py-class docutils literal"><span class="pre">sf.Text</span></tt></a>.</p>
<p>Usage example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># declare a new font</span>
<span class="k">try</span><span class="p">:</span>
   <span class="n">font</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Font</span><span class="o">.</span><span class="n">load_from_file</span><span class="p">(</span><span class="s">&quot;arial.ttf&quot;</span><span class="p">)</span>

<span class="k">except</span> <span class="n">sf</span><span class="o">.</span><span class="n">SFMLException</span><span class="p">:</span> <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c"># error...</span>

<span class="c"># create a text which uses our font</span>
<span class="n">text1</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Text</span><span class="p">()</span>
<span class="n">text1</span><span class="o">.</span><span class="n">font</span> <span class="o">=</span> <span class="n">font</span>
<span class="n">text1</span><span class="o">.</span><span class="n">character_size</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">text1</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Text</span><span class="o">.</span><span class="n">REGULAR</span>

<span class="c"># create another text using the same font, but with different parameters</span>
<span class="n">text2</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Text</span><span class="p">()</span>
<span class="n">text2</span><span class="o">.</span><span class="n">font</span> <span class="o">=</span> <span class="n">font</span>
<span class="n">text2</span><span class="o">.</span><span class="n">character_size</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">text2</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Text</span><span class="o">.</span><span class="n">ITALIC</span>
</pre></div>
</div>
<p>Apart from loading font files, and passing them to instances of
<a class="reference internal" href="#sf.Text" title="sf.Text"><tt class="xref py py-class docutils literal"><span class="pre">sf.Text</span></tt></a>, you should normally not have to deal directly
with this class. However, it may be useful to access the font
metrics or rasterized glyphs for advanced usage.</p>
</div></blockquote>
<dl class="method">
<dt id="sf.Font.Font">
<tt class="descname">Font</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Font.Font" title="Permalink to this definition">¶</a></dt>
<dd><p>The default constructor is not meant to be called. It will raise
<tt class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></tt> with a message telling you that you
must use a specific constructor.</p>
<p>Those specific constructors are: <a class="reference internal" href="#sf.Font.load_from_file" title="sf.Font.load_from_file"><tt class="xref py py-func docutils literal"><span class="pre">load_from_file()</span></tt></a> and
<a class="reference internal" href="#sf.Font.load_from_memory" title="sf.Font.load_from_memory"><tt class="xref py py-func docutils literal"><span class="pre">load_from_memory()</span></tt></a>.</p>
</dd></dl>

<dl class="classmethod">
<dt id="sf.Font.load_from_file">
<em class="property">classmethod </em><tt class="descname">load_from_file</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#sf.Font.load_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the font from a file.</p>
<p>The supported font formats are: TrueType, Type 1, CFF, OpenType,
SFNT, X11 PCF, Windows FNT, BDF, PFR and Type 42. Note that this
function know nothing about the standard fonts installed on the
user&#8217;s system, thus you can&#8217;t load them directly.</p>
<p>This function raises an exception if it fails.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raise :</th><td class="field-body"><a class="reference internal" href="system.html#sf.SFMLException" title="sf.SFMLException"><tt class="xref py py-exc docutils literal"><span class="pre">sf.SFMLException</span></tt></a> - If it fails.</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>string</em>) &#8211; Path of the font file to load</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Font" title="sf.Font"><tt class="xref py py-class docutils literal"><span class="pre">sf.Font</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="sf.Font.load_from_memory">
<em class="property">classmethod </em><tt class="descname">load_from_memory</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#sf.Font.load_from_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the font from a file in memory.</p>
<p>The supported font formats are: TrueType, Type 1, CFF, OpenType,
SFNT, X11 PCF, Windows FNT, BDF, PFR and Type 42. Note that this
function know nothing about the standard fonts installed on the
user&#8217;s system, thus you can&#8217;t load them directly.</p>
<p>This function raises an exception if it fails.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raise :</th><td class="field-body"><a class="reference internal" href="system.html#sf.SFMLException" title="sf.SFMLException"><tt class="xref py py-exc docutils literal"><span class="pre">sf.SFMLException</span></tt></a> - If it fails.</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>bytes</em>) &#8211; The data to load</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Font" title="sf.Font"><tt class="xref py py-class docutils literal"><span class="pre">sf.Font</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Font.get_glyph">
<tt class="descname">get_glyph</tt><big>(</big><em>code_point</em>, <em>character_size</em>, <em>bold</em><big>)</big><a class="headerlink" href="#sf.Font.get_glyph" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a glyph of the font.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>code_point</strong> (<em>integer</em>) &#8211; Unicode code point of the character to get</li>
<li><strong>character_size</strong> (<em>integer</em>) &#8211; Reference character size</li>
<li><strong>bold</strong> (<em>bool</em>) &#8211; Retrieve the bold version or the regular one ?</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The glyph corresponding to <em>code_point</em> and <em>character_size</em></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#sf.Glyph" title="sf.Glyph"><tt class="xref py py-class docutils literal"><span class="pre">sf.Glyph</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Font.get_kerning">
<tt class="descname">get_kerning</tt><big>(</big><em>first</em>, <em>second</em>, <em>character_size</em><big>)</big><a class="headerlink" href="#sf.Font.get_kerning" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the kerning offset of two glyphs.</p>
<p>The kerning is an extra offset (negative) to apply between two
glyphs when rendering them, to make the pair look more &#8220;natural&#8221;.
For example, the pair &#8220;AV&#8221; have a special kerning to make them
closer than other characters. Most of the glyphs pairs have a
kerning offset of zero, though.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>first</strong> (<em>integer</em>) &#8211; Unicode code point of the first character</li>
<li><strong>second</strong> (<em>integer</em>) &#8211; Unicode code point of the second character</li>
<li><strong>character_size</strong> (<em>integer</em>) &#8211; Reference character size</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Kerning value for first and second, in pixels</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">integer</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Font.get_line_spacing">
<tt class="descname">get_line_spacing</tt><big>(</big><em>character_size</em><big>)</big><a class="headerlink" href="#sf.Font.get_line_spacing" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the line spacing.</p>
<p>Line spacing is the vertical offset to apply between two
consecutive lines of text.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>character_size</strong> (<em>integer</em>) &#8211; Reference character size</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Line spacing, in pixels</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Font.get_texture">
<tt class="descname">get_texture</tt><big>(</big><em>character_size</em><big>)</big><a class="headerlink" href="#sf.Font.get_texture" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the texture containing the loaded glyphs of a certain
size.</p>
<p>The contents of the returned texture changes as more glyphs are
requested, thus it is not very relevant. It is mainly used
internally by <a class="reference internal" href="#sf.Text" title="sf.Text"><tt class="xref py py-class docutils literal"><span class="pre">sf.Text</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>character_size</strong> (<em>integer</em>) &#8211; Reference character size</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Texture containing the glyphs of the requested size</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="sf.Font.get_default_font">
<em class="property">classmethod </em><tt class="descname">get_default_font</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Font.get_default_font" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default built-in font.</p>
<p>This font is provided for convenience, it is used by
<a class="reference internal" href="#sf.Text" title="sf.Text"><tt class="xref py py-class docutils literal"><span class="pre">sf.Text</span></tt></a> instances by default. It is provided so that
users don&#8217;t have to provide and load a font file in order to
display text on screen. The font used is Arial.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Reference to the built-in default font</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Font" title="sf.Font"><tt class="xref py py-class docutils literal"><span class="pre">sf.Font</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.Shader">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">Shader</tt><a class="headerlink" href="#sf.Shader" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#sf.Shader" title="sf.Shader"><tt class="xref py py-class docutils literal"><span class="pre">Shader</span></tt></a> class (vertex and fragment)</p>
<p>Shaders are programs written using a specific language, executed
directly by the graphics card and allowing to apply real-time
operations to the rendered entities.</p>
<p>There are two kinds of shaders:</p>
<blockquote>
<div><ul class="simple">
<li>Vertex shaders, that process vertices</li>
<li>Fragment (pixel) shaders, that process pixels</li>
</ul>
</div></blockquote>
<p>A <a class="reference internal" href="#sf.Shader" title="sf.Shader"><tt class="xref py py-class docutils literal"><span class="pre">sf.Shader</span></tt></a> can be composed of either a vertex shader
alone, a fragment shader alone, or both combined (see the variants
of the load functions).</p>
<p>Shaders are written in GLSL, which is a C-like language dedicated to
OpenGL shaders. You&#8217;ll probably need to learn its basics before
writing your own shaders for pySFML.</p>
<p>Like any C/C++ program, a shader has its own variables that you can
set from your Python application. <a class="reference internal" href="#sf.Shader" title="sf.Shader"><tt class="xref py py-class docutils literal"><span class="pre">sf.Shader</span></tt></a> handles 4
different types of variables:</p>
<blockquote>
<div><ul class="simple">
<li>floats</li>
<li>vectors (2, 3 or 4 components)</li>
<li>textures</li>
<li>transforms (matrices)</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="sf.Shader.Shader">
<tt class="descname">Shader</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Shader.Shader" title="Permalink to this definition">¶</a></dt>
<dd><p>The default constructor is not meant to be called. It will raise
<tt class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></tt> with a message telling you that you
must use a specific constructor.</p>
<p>Those specific constructors are: <a class="reference internal" href="#sf.Shader.load_from_file" title="sf.Shader.load_from_file"><tt class="xref py py-func docutils literal"><span class="pre">load_from_file()</span></tt></a> and
<a class="reference internal" href="#sf.Shader.load_from_memory" title="sf.Shader.load_from_memory"><tt class="xref py py-func docutils literal"><span class="pre">load_from_memory()</span></tt></a>.</p>
</dd></dl>

<dl class="data">
<dt id="sf.Shader.VERTEX">
<tt class="descname">VERTEX</tt><a class="headerlink" href="#sf.Shader.VERTEX" title="Permalink to this definition">¶</a></dt>
<dd><p>Vertex shader.</p>
</dd></dl>

<dl class="data">
<dt id="sf.Shader.FRAGMENT">
<tt class="descname">FRAGMENT</tt><a class="headerlink" href="#sf.Shader.FRAGMENT" title="Permalink to this definition">¶</a></dt>
<dd><p>Fragment (pixel) shader.</p>
</dd></dl>

<dl class="classmethod">
<dt id="sf.Shader.load_from_file">
<em class="property">classmethod </em><tt class="descname">load_from_file</tt><big>(</big><em>filename</em>, <em>type</em><big>)</big><a class="headerlink" href="#sf.Shader.load_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Load either the vertex or fragment shader from a file.</p>
<p>This function loads a single shader, either vertex or fragment,
identified by the second argument. The source must be a text file
containing a valid shader in GLSL language. GLSL is a C-like
language dedicated to OpenGL shaders; you&#8217;ll probably need to
read a good documentation for it before writing your own shaders.</p>
<p>This function raises an exception if it fails.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raise :</th><td class="field-body"><p class="first"><a class="reference internal" href="system.html#sf.SFMLException" title="sf.SFMLException"><tt class="xref py py-exc docutils literal"><span class="pre">sf.SFMLException</span></tt></a> - If it fails.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<em>string</em>) &#8211; Path of the vertex or fragment shader file to load.</li>
<li><strong>type</strong> (<a class="reference internal" href="#sf.Shader" title="sf.Shader"><tt class="xref py py-class docutils literal"><span class="pre">sf.Shader</span></tt></a>&#8216;s constant) &#8211; Type of shader (vertex or fragment)</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#sf.Shader" title="sf.Shader"><tt class="xref py py-class docutils literal"><span class="pre">sf.Shader</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="sf.Shader.load_from_memory">
<em class="property">classmethod </em><tt class="descname">load_from_memory</tt><big>(</big><em>data</em>, <em>type</em><big>)</big><a class="headerlink" href="#sf.Shader.load_from_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Load either the vertex or fragment shader from a source code in
memory.</p>
<p>This function loads a single shader, either vertex or fragment,
identified by the second argument. The source code must be a
valid shader in GLSL language. GLSL is a C-like language
dedicated to OpenGL shaders; you&#8217;ll probably need to read a good
documentation for it before writing your own shaders.</p>
<p>This function raises an exception if it fails.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raise :</th><td class="field-body"><p class="first"><a class="reference internal" href="system.html#sf.SFMLException" title="sf.SFMLException"><tt class="xref py py-exc docutils literal"><span class="pre">sf.SFMLException</span></tt></a> - If it fails.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>bytes</em>) &#8211; String containing the source code of the shader</li>
<li><strong>type</strong> (<a class="reference internal" href="#sf.Shader" title="sf.Shader"><tt class="xref py py-class docutils literal"><span class="pre">sf.Shader</span></tt></a>&#8216;s constant) &#8211; Type of shader (vertex or fragment)</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#sf.Shader" title="sf.Shader"><tt class="xref py py-class docutils literal"><span class="pre">sf.Shader</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Shader.set_parameter">
<tt class="descname">set_parameter</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Shader.set_parameter" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Not implemented yet. It will be in the next realease.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sf.Shader.bind">
<tt class="descname">bind</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Shader.bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind the shader for rendering (activate it)</p>
<p>This function is normally for internal use only, unless you want
to use the shader with a custom OpenGL rendering instead of a
SFML drawable.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">window</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">shader</span><span class="o">.</span><span class="n">bind</span><span class="p">()</span>
<span class="c"># ... render OpenGL geometry ...</span>
<span class="n">shader</span><span class="o">.</span><span class="n">unbind</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sf.Shader.unbind">
<tt class="descname">unbind</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Shader.unbind" title="Permalink to this definition">¶</a></dt>
<dd><p>Unbind the shader (deactivate it)</p>
<p>This function is normally for internal use only, unless you want
to use the shader with a custom OpenGL rendering instead of a
SFML drawable.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.RenderStates">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">RenderStates</tt><a class="headerlink" href="#sf.RenderStates" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the states used for drawing to a <a class="reference internal" href="#sf.RenderTarget" title="sf.RenderTarget"><tt class="xref py py-class docutils literal"><span class="pre">RenderTarget</span></tt></a>.</p>
<p>There are four global states that can be applied to the drawn
objects:</p>
<blockquote>
<div><ul class="simple">
<li>the blend mode: how pixels of the object are blended with the background</li>
<li>the transform: how the object is positioned/rotated/scaled</li>
<li>the texture: what image is mapped to the object</li>
<li>the shader: what custom effect is applied to the object</li>
</ul>
</div></blockquote>
<p>High-level objects such as sprites or text force some of these
states when they are drawn. For example, a sprite will set its own
texture, so that you don&#8217;t have to care about it when drawing the
sprite.</p>
<p>The transform is a special case: sprites, texts and shapes (and it&#8217;s
a good idea to do it with your own drawable classes too) combine
their transform with the one that is passed in the
<a class="reference internal" href="#sf.RenderStates" title="sf.RenderStates"><tt class="xref py py-class docutils literal"><span class="pre">RenderStates</span></tt></a> structure. So that you can use a &#8220;global&#8221;
transform on top of each object&#8217;s transform.</p>
<p>Most objects, especially high-level drawables, can be drawn directly
without defining render states explicitely &#8211; the default set of
states is ok in most cases.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">window</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
</pre></div>
</div>
<p>If you want to use a single specific render state, for example a
shader, you can pass it directly to the draw function.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">window</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">shader</span><span class="p">)</span>
</pre></div>
</div>
<p>When you&#8217;re inside the draw function of a drawable object (inherited
from <a class="reference internal" href="#sf.Drawable" title="sf.Drawable"><tt class="xref py py-class docutils literal"><span class="pre">sf.Drawable</span></tt></a>), you can either pass the render states
unmodified, or change some of them. For example, a transformable
object will combine the current transform with its own transform. A
sprite will set its texture. Etc.</p>
<dl class="method">
<dt>
<tt class="descname">RenderStates(blend_mode=sf.BlendMode.BLEND_ALPHA[, transform=None, [texture=None[, shader=None]]]</tt></dt>
<dd><p>Construct a default render states with custom values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>blend_mode</strong> (<tt class="xref py py-class docutils literal"><span class="pre">sf.BlendMode</span></tt>&#8216;s constant) &#8211; Blend mode to use</li>
<li><strong>transform</strong> (<a class="reference internal" href="#sf.Transform" title="sf.Transform"><em>sf.Transform</em></a>) &#8211; Transform to use</li>
<li><strong>texture</strong> (<a class="reference internal" href="#sf.Texture" title="sf.Texture"><em>sf.Texture</em></a>) &#8211; Texture to use</li>
<li><strong>shader</strong> (<a class="reference internal" href="#sf.Shader" title="sf.Shader"><em>sf.Shader</em></a>) &#8211; Shader to use</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#sf.RenderStates" title="sf.RenderStates"><tt class="xref py py-class docutils literal"><span class="pre">sf.RenderStates</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="data">
<dt id="sf.RenderStates.DEFAULT">
<tt class="descname">DEFAULT</tt><a class="headerlink" href="#sf.RenderStates.DEFAULT" title="Permalink to this definition">¶</a></dt>
<dd><p>Special instance holding the default render states.</p>
</dd></dl>

<dl class="attribute">
<dt id="sf.RenderStates.blend_mode">
<tt class="descname">blend_mode</tt><a class="headerlink" href="#sf.RenderStates.blend_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Blending mode.</p>
</dd></dl>

<dl class="attribute">
<dt id="sf.RenderStates.transform">
<tt class="descname">transform</tt><a class="headerlink" href="#sf.RenderStates.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform.</p>
</dd></dl>

<dl class="attribute">
<dt id="sf.RenderStates.texture">
<tt class="descname">texture</tt><a class="headerlink" href="#sf.RenderStates.texture" title="Permalink to this definition">¶</a></dt>
<dd><p>Texture.</p>
</dd></dl>

<dl class="attribute">
<dt id="sf.RenderStates.shader">
<tt class="descname">shader</tt><a class="headerlink" href="#sf.RenderStates.shader" title="Permalink to this definition">¶</a></dt>
<dd><p>Shader.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.Drawable">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">Drawable</tt><a class="headerlink" href="#sf.Drawable" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for objects that can be drawn to a render target.</p>
<p><a class="reference internal" href="#sf.Drawable" title="sf.Drawable"><tt class="xref py py-class docutils literal"><span class="pre">sf.Drawable</span></tt></a> is a very simple base class that allows objects
of derived classes to be drawn to a <a class="reference internal" href="#sf.RenderTarget" title="sf.RenderTarget"><tt class="xref py py-class docutils literal"><span class="pre">sf.RenderTarget</span></tt></a>.</p>
<p>All you have to do in your derived class is to override the draw
virtual function.</p>
<p>Note that inheriting from <a class="reference internal" href="#sf.Drawable" title="sf.Drawable"><tt class="xref py py-class docutils literal"><span class="pre">sf.Drawable</span></tt></a> is not mandatory, but
it allows this nice syntax &#8220;window.draw(object)&#8221; rather than
&#8220;object.draw(window)&#8221;, which is more consistent with other pySFML
classes.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyDrawable</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">Drawable</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">sf</span><span class="o">.</span><span class="n">Drawable</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
      <span class="c"># ...</span>

   <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
      <span class="c"># you can draw other high-level objects</span>
      <span class="n">target</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sprite</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>

      <span class="c"># ... or use the low-level API</span>
      <span class="n">states</span><span class="o">.</span><span class="n">texture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">texture</span>
      <span class="n">target</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>

      <span class="c"># ... or draw with OpenGL directly</span>
      <span class="n">glBegin</span><span class="p">(</span><span class="n">GL_QUADS</span><span class="p">)</span>
         <span class="c"># ...</span>
      <span class="n">glEnd</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt>
<tt class="descname">draw(target, states):</tt></dt>
<dd><p>Draw the object to a render target.</p>
<p>This is a virtual method that has to be implemented by the
derived class to define how the drawable should be drawn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>target</strong> (<a class="reference internal" href="#sf.RenderTarget" title="sf.RenderTarget"><em>sf.RenderTarget</em></a>) &#8211; Render target to draw to</li>
<li><strong>states</strong> (<a class="reference internal" href="#sf.RenderStates" title="sf.RenderStates"><em>sf.RenderStates</em></a>) &#8211; Current render states</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.Transformable">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">Transformable</tt><a class="headerlink" href="#sf.Transformable" title="Permalink to this definition">¶</a></dt>
<dd><p>Decomposed transform defined by a position, a rotation and a scale.</p>
<p>This class is provided for convenience, on top of
<a class="reference internal" href="#sf.Transform" title="sf.Transform"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transform</span></tt></a>.</p>
<p><a class="reference internal" href="#sf.Transform" title="sf.Transform"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transform</span></tt></a>, as a low-level class, offers a great level of
flexibility but it is not always convenient to manage. Indeed, one
can easily combine any kind of operation, such as a translation
followed by a rotation followed by a scaling, but once the result
transform is built, there&#8217;s no way to go backward and, let&#8217;s say,
change only the rotation without modifying the translation and
scaling. The entire transform must be recomputed, which means that
you need to retrieve the initial translation and scale factors as
well, and combine them the same way you did before updating the
rotation. This is a tedious operation, and it requires to store all
the individual components of the final transform.</p>
<p>That&#8217;s exactly what <a class="reference internal" href="#sf.Transformable" title="sf.Transformable"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transformable</span></tt></a> was written for: it
hides these variables and the composed transform behind an easy to
use interface. You can set or get any of the individual components
without worrying about the others. It also provides the composed
transform (as a <a class="reference internal" href="#sf.Transform" title="sf.Transform"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transform</span></tt></a>), and keeps it up-to-date.</p>
<p>In addition to the position, rotation and scale,
<a class="reference internal" href="#sf.Transformable" title="sf.Transformable"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transformable</span></tt></a> provides an &#8220;origin&#8221; component, which
represents the local origin of the three other components. Let&#8217;s
take an example with a 10x10 pixels sprite. By default, the sprite
is positionned/rotated/scaled relatively to its top-left corner,
because it is the local point (0, 0). But if we change the origin to
be (5, 5), the sprite will be positionned/rotated/scaled around its
center instead. And if we set the origin to (10, 10), it will be
transformed around its bottom-right corner.</p>
<p>To keep the <a class="reference internal" href="#sf.Transformable" title="sf.Transformable"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transformable</span></tt></a> class simple, there&#8217;s only one
origin for all the components. You cannot position the sprite
relatively to its top-left corner while rotating it around its
center, for example. To do such things, use
<a class="reference internal" href="#sf.Transform" title="sf.Transform"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transform</span></tt></a> directly.</p>
<p><a class="reference internal" href="#sf.Transformable" title="sf.Transformable"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transformable</span></tt></a> can be used as a base class. It is often
combined with <a class="reference internal" href="#sf.Drawable" title="sf.Drawable"><tt class="xref py py-class docutils literal"><span class="pre">sf.Drawable</span></tt></a> &#8211; that&#8217;s what SFML&#8217;s sprites,
texts and shapes do.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyEntity</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">TransformableDrawable</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
      <span class="n">states</span><span class="o">.</span><span class="n">transform</span> <span class="o">*=</span> <span class="n">get_transform</span><span class="p">()</span>
      <span class="n">target</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>

<span class="n">entity</span> <span class="o">=</span> <span class="n">MyEntity</span><span class="p">()</span>
<span class="n">entity</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">entity</span><span class="o">.</span><span class="n">rotation</span> <span class="o">=</span> <span class="mi">45</span>
<span class="n">window</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="sf.Transformable.Transformable">
<tt class="descname">Transformable</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Transformable.Transformable" title="Permalink to this definition">¶</a></dt>
<dd><p>Default constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Transformable" title="sf.Transformable"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transformable</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Transformable.position">
<tt class="descname">position</tt><a class="headerlink" href="#sf.Transformable.position" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/get the position of the object</p>
<p>This attribute completely overwrites the previous position. See
<a class="reference internal" href="#sf.Transformable.move" title="sf.Transformable.move"><tt class="xref py py-func docutils literal"><span class="pre">move()</span></tt></a> to apply an offset based on the previous position
instead. The default position of a transformable object is (0, 0).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Position" title="sf.Position"><tt class="xref py py-class docutils literal"><span class="pre">sf.Position</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Transformable.rotation">
<tt class="descname">rotation</tt><a class="headerlink" href="#sf.Transformable.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/get the orientation of the object</p>
<p>This attribute completely overwrites the previous rotation. See
<a class="reference internal" href="#sf.Transformable.rotate" title="sf.Transformable.rotate"><tt class="xref py py-func docutils literal"><span class="pre">rotate()</span></tt></a> to add an angle based on the previous rotation
instead. The default rotation of a transformable object is 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Transformable.ratio">
<tt class="descname">ratio</tt><a class="headerlink" href="#sf.Transformable.ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/get the scale factors of the object</p>
<p>This function completely overwrites the previous ratio. See
<a class="reference internal" href="#sf.Transformable.scale" title="sf.Transformable.scale"><tt class="xref py py-func docutils literal"><span class="pre">scale()</span></tt></a> to add a factor based on the previous scale
instead. The default scale of a transformable object is (1, 1).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Position" title="sf.Position"><tt class="xref py py-class docutils literal"><span class="pre">sf.Position</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Transformable.origin">
<tt class="descname">origin</tt><a class="headerlink" href="#sf.Transformable.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/get the local origin of the object</p>
<p>The origin of an object defines the center point for all
transformations (position, scale, rotation). The coordinates of
this point must be relative to the top-left corner of the object,
and ignore all transformations (position, scale, rotation). The
default origin of a transformable object is (0, 0).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Position" title="sf.Position"><tt class="xref py py-class docutils literal"><span class="pre">sf.Position</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Transformable.move">
<tt class="descname">move</tt><big>(</big><em>offset</em><big>)</big><a class="headerlink" href="#sf.Transformable.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move the object by a given offset.</p>
<p>This function adds to the current position of the object, unlike
<a class="reference internal" href="#sf.Transformable.position" title="sf.Transformable.position"><tt class="xref py py-attr docutils literal"><span class="pre">position</span></tt></a> which overwrites it. Thus, it is equivalent to
the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">object</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">offset</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>offset</strong> (<a class="reference internal" href="system.html#sf.Position" title="sf.Position"><em>sf.Position</em></a>) &#8211; Offset</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.Transformable.rotate">
<tt class="descname">rotate</tt><big>(</big><em>angle</em><big>)</big><a class="headerlink" href="#sf.Transformable.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the object.</p>
<p>This function adds to the current rotation of the object, unlike
<a class="reference internal" href="#sf.Transformable.rotation" title="sf.Transformable.rotation"><tt class="xref py py-attr docutils literal"><span class="pre">rotation</span></tt></a> which overwrites it. Thus, it is equivalent to
the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">object</span><span class="o">.</span><span class="n">rotation</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">rotation</span> <span class="o">+</span> <span class="n">angle</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sf.Transformable.scale">
<tt class="descname">scale</tt><big>(</big><em>factor</em><big>)</big><a class="headerlink" href="#sf.Transformable.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale the object.</p>
<p>This function multiplies the current scale of the object, unlike
<a class="reference internal" href="#sf.Transformable.ratio" title="sf.Transformable.ratio"><tt class="xref py py-attr docutils literal"><span class="pre">ratio</span></tt></a> which overwrites it. Thus, it is equivalent to the
following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">object</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">ratio</span> <span class="o">*</span> <span class="n">factor</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sf.Transformable.transform">
<tt class="descname">transform</tt><a class="headerlink" href="#sf.Transformable.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the combined transform of the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Transform" title="sf.Transform"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transform</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Transformable.inverse_transform">
<tt class="descname">inverse_transform</tt><a class="headerlink" href="#sf.Transformable.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the inverse of the combined transform of the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Transform" title="sf.Transform"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transform</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.Sprite">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">Sprite</tt><big>(</big><em>sf.Drawable</em>, <em>sf.Transformable</em><big>)</big><a class="headerlink" href="#sf.Sprite" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#sf.Drawable" title="sf.Drawable"><tt class="xref py py-class docutils literal"><span class="pre">Drawable</span></tt></a> representation of a texture, with its own
transformations, color, etc.</p>
<p><a class="reference internal" href="#sf.Sprite" title="sf.Sprite"><tt class="xref py py-class docutils literal"><span class="pre">sf.Sprite</span></tt></a> is a drawable class that allows to easily display
a texture (or a part of it) on a render target.</p>
<p>It inherits all the functions from <a class="reference internal" href="#sf.Transformable" title="sf.Transformable"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transformable</span></tt></a>:
position, rotation, scale, origin. It also adds sprite-specific
properties such as the texture to use, the part of it to display,
and some convenience functions to change the overall color of the
sprite, or to get its bounding rectangle.</p>
<p><a class="reference internal" href="#sf.Sprite" title="sf.Sprite"><tt class="xref py py-class docutils literal"><span class="pre">sf.Sprite</span></tt></a> works in combination with the <a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a>
class, which loads and provides the pixel data of a given texture.</p>
<p>The separation of <tt class="xref py py-class docutils literal"><span class="pre">sf..Sprite</span></tt> and <a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a> allows
more flexibility and better performances: indeed a
<a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a> is a heavy resource, and any operation on it is
slow (often too slow for real-time applications). On the other side,
a <a class="reference internal" href="#sf.Sprite" title="sf.Sprite"><tt class="xref py py-class docutils literal"><span class="pre">sf.Sprite</span></tt></a> is a lightweight object which can use the pixel
data of a <a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a> and draw it with its own
transformation/color/blending attributes.</p>
<p>It is important to note that the <a class="reference internal" href="#sf.Sprite" title="sf.Sprite"><tt class="xref py py-class docutils literal"><span class="pre">sf.Sprite</span></tt></a> instance doesn&#8217;t
copy the texture that it uses, it only keeps a reference to it.
Thus, a <a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a> must not be destroyed while it is used
by a <a class="reference internal" href="#sf.Sprite" title="sf.Sprite"><tt class="xref py py-class docutils literal"><span class="pre">sf.Sprite</span></tt></a>.</p>
<p>Usage examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># declare and load a texture</span>
<span class="n">texture</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Texture</span><span class="o">.</span><span class="n">load_from_file</span><span class="p">(</span><span class="s">&quot;texture.png&quot;</span><span class="p">)</span>

<span class="c"># create a sprite</span>
<span class="n">sprite</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Sprite</span><span class="p">(</span><span class="n">texture</span><span class="p">)</span>
<span class="n">sprite</span><span class="o">.</span><span class="n">texture_rectangle</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
<span class="n">sprite</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="n">sprite</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Position</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>

<span class="c"># draw it</span>
<span class="n">window</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="sf.Sprite.Sprite">
<tt class="descname">Sprite</tt><big>(</big><em>texture</em><span class="optional">[</span>, <em>rectangle</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.Sprite.Sprite" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the sprite from (a sub-rectangle of) a source texture.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>texture</strong> (<a class="reference internal" href="#sf.Texture" title="sf.Texture"><em>sf.Texture</em></a>) &#8211; Source texture</li>
<li><strong>rectangle</strong> (<a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><em>sf.Rectangle</em></a>) &#8211; Sub-rectangle of the texture to assign to the sprite</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Sprite.texture">
<tt class="descname">texture</tt><a class="headerlink" href="#sf.Sprite.texture" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the source texture of the sprite.</p>
<p>The texture argument refers to a texture that must exist as long
as the sprite uses it. Indeed, the sprite doesn&#8217;t store its own
copy of the texture, but rather keeps a pointer to the one that
you passed to this function. If the source texture is destroyed
and the sprite tries to use it, the behaviour is undefined. The
<a class="reference internal" href="#sf.Sprite.texture_rectangle" title="sf.Sprite.texture_rectangle"><tt class="xref py py-attr docutils literal"><span class="pre">texture_rectangle</span></tt></a> property of the sprite is automatically
adjusted to the size of the new texture</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that in C++, you must explicitly tell you want the texture rectangle to be reset. Here, the texture rectangle is reset by default.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Sprite.texture_rectangle">
<tt class="descname">texture_rectangle</tt><a class="headerlink" href="#sf.Sprite.texture_rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/get the sub-rectangle of the texture that the sprite will
display.</p>
<p>The texture rectangle is useful when you don&#8217;t want to display
the whole texture, but rather a part of it. By default, the
texture rectangle covers the entire texture.</p>
</dd></dl>

<dl class="attribute">
<dt id="sf.Sprite.color">
<tt class="descname">color</tt><a class="headerlink" href="#sf.Sprite.color" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/get the global color of the sprite.</p>
<p>This color is modulated (multiplied) with the sprite&#8217;s texture.
It can be used to colorize the sprite, or change its global
opacity. By default, the sprite&#8217;s color is opaque white.</p>
</dd></dl>

<dl class="attribute">
<dt id="sf.Sprite.local_bounds">
<tt class="descname">local_bounds</tt><a class="headerlink" href="#sf.Sprite.local_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the local bounding rectangle of the entity.</p>
<p>The returned rectangle is in local coordinates, which means that
it ignores the transformations (translation, rotation, scale,
...) that are applied to the entity. In other words, this
function returns the bounds of the entity in the entity&#8217;s
coordinate system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Sprite.global_bounds">
<tt class="descname">global_bounds</tt><a class="headerlink" href="#sf.Sprite.global_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the global bounding rectangle of the entity.</p>
<p>The returned rectangle is in global coordinates, which means that
it takes in account the transformations (translation, rotation,
scale, ...) that are applied to the entity. In other words, this
function returns the bounds of the sprite in the global 2D
world&#8217;s coordinate system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.Text">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">Text</tt><a class="headerlink" href="#sf.Text" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Graphical text that can be drawn to a render target.</p>
<p><a class="reference internal" href="#sf.Text" title="sf.Text"><tt class="xref py py-class docutils literal"><span class="pre">sf.Text</span></tt></a> is a drawable class that allows to easily
display some text with custom style and color on a render target.</p>
<p>It inherits all the functions from <a class="reference internal" href="#sf.Transformable" title="sf.Transformable"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transformable</span></tt></a>:
position, ratio, scale, origin. It also adds text-specific
properties such as the font to use, the character size, the font
style (bold, italic, underlined), the global color and the text
to display of course. It also provides convenience functions to
calculate the graphical size of the text, or to get the global
position of a given character.</p>
<p>:class:&#8217;sf.Text` works in combination with the <a class="reference internal" href="#sf.Font" title="sf.Font"><tt class="xref py py-class docutils literal"><span class="pre">sf.Font</span></tt></a>
class, which loads and provides the glyphs (visual characters) of
a given font.</p>
<p>The separation of <a class="reference internal" href="#sf.Font" title="sf.Font"><tt class="xref py py-class docutils literal"><span class="pre">sf.Font</span></tt></a> and <a class="reference internal" href="#sf.Text" title="sf.Text"><tt class="xref py py-class docutils literal"><span class="pre">sf.Text</span></tt></a> allows
more flexibility and better performances: indeed a :<cite>sf.Font</cite> is
a heavy resource, and any operation on it is slow (often too slow
for real-time applications). On the other side, a
<a class="reference internal" href="#sf.Text" title="sf.Text"><tt class="xref py py-class docutils literal"><span class="pre">sf.Text</span></tt></a> is a lightweight object which can combine the
glyphs data and metrics of a <a class="reference internal" href="#sf.Font" title="sf.Font"><tt class="xref py py-class docutils literal"><span class="pre">sf.Font</span></tt></a> to display any text
on a render target.</p>
<p>It is important to note that the <a class="reference internal" href="#sf.Text" title="sf.Text"><tt class="xref py py-class docutils literal"><span class="pre">sf.Text</span></tt></a> instance
doesn&#8217;t copy the font that it uses, it only keeps a reference to
it. Thus, a <a class="reference internal" href="#sf.Font" title="sf.Font"><tt class="xref py py-class docutils literal"><span class="pre">sf.Font</span></tt></a> must not be destructed while it is
used by a <a class="reference internal" href="#sf.Text" title="sf.Text"><tt class="xref py py-class docutils literal"><span class="pre">sf.Text</span></tt></a>.</p>
<p>Usage example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># declare and load a font</span>
<span class="k">try</span><span class="p">:</span>
   <span class="n">font</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Font</span><span class="o">.</span><span class="n">load_from_file</span><span class="p">(</span><span class="s">&quot;arial.ttf&quot;</span><span class="p">)</span>

<span class="k">except</span> <span class="n">sf</span><span class="o">.</span><span class="n">SFMLException</span><span class="p">:</span> <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># create a text</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
<span class="n">text</span><span class="o">.</span><span class="n">font</span> <span class="o">=</span> <span class="n">font</span>
<span class="n">text</span><span class="o">.</span><span class="n">character_size</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">text</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Text</span><span class="o">.</span><span class="n">BOLD</span>
<span class="n">text</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="o">.</span><span class="n">RED</span>

<span class="c"># draw it</span>
<span class="n">window</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that you don&#8217;t need to load a font to draw text, pySFML
comes with a built-in font that is implicitely used by default.</p>
</div></blockquote>
<dl class="method">
<dt id="sf.Text.Text">
<tt class="descname">Text</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Text.Text" title="Permalink to this definition">¶</a></dt>
<dd><p>F</p>
</dd></dl>

<dl class="data">
<dt id="sf.Text.REGULAR">
<tt class="descname">REGULAR</tt><a class="headerlink" href="#sf.Text.REGULAR" title="Permalink to this definition">¶</a></dt>
<dd><p>Regular characters, no style.</p>
</dd></dl>

<dl class="data">
<dt id="sf.Text.BOLD">
<tt class="descname">BOLD</tt><a class="headerlink" href="#sf.Text.BOLD" title="Permalink to this definition">¶</a></dt>
<dd><p>Bold characters.</p>
</dd></dl>

<dl class="data">
<dt id="sf.Text.ITALIC">
<tt class="descname">ITALIC</tt><a class="headerlink" href="#sf.Text.ITALIC" title="Permalink to this definition">¶</a></dt>
<dd><p>Italic characters.</p>
</dd></dl>

<dl class="data">
<dt id="sf.Text.UNDERLINED">
<tt class="descname">UNDERLINED</tt><a class="headerlink" href="#sf.Text.UNDERLINED" title="Permalink to this definition">¶</a></dt>
<dd><p>Underlined characters.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.Shape">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">Shape</tt><big>(</big><em>sf.Drawable</em>, <em>sf.Transformable</em><big>)</big><a class="headerlink" href="#sf.Shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for textured shapes with outline.</p>
<p><a class="reference internal" href="#sf.Shape" title="sf.Shape"><tt class="xref py py-class docutils literal"><span class="pre">sf.Shape</span></tt></a> is a drawable class that allows to define and
display a custom convex shape on a render target.</p>
<p>It&#8217;s only an abstract base, it needs to be specialized for concrete
types of shapes (circle, rectangle, convex polygon, star, ...).</p>
<p>In addition to the attributes provided by the specialized shape
classes, a shape always has the following attributes:</p>
<blockquote>
<div><ul class="simple">
<li>a texture</li>
<li>a texture rectangle</li>
<li>a fill color</li>
<li>an outline color</li>
<li>an outline thickness</li>
</ul>
</div></blockquote>
<p>Each feature is optional, and can be disabled easily:</p>
<blockquote>
<div><ul class="simple">
<li>the texture can be null</li>
<li>the fill/outline colors can be <a class="reference internal" href="#sf.Color.TRANSPARENT" title="sf.Color.TRANSPARENT"><tt class="xref py py-const docutils literal"><span class="pre">sf.Color.TRANSPARENT</span></tt></a></li>
<li>the outline thickness can be zero</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="sf.Shape.Shape">
<tt class="descname">Shape</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.Shape.Shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="sf.Shape.texture">
<tt class="descname">texture</tt><a class="headerlink" href="#sf.Shape.texture" title="Permalink to this definition">¶</a></dt>
<dd><p>Change or get the source texture of the shape.</p>
<p>The texture argument refers to a texture that must exist as long
as the shape uses it. Indeed, the shape doesn&#8217;t store its own
copy of the texture, but rather keeps a pointer to the one that y
ou passed to this function. If the source texture is destroyed
and the shape tries to use it, the behaviour is undefined.
texture can be <em>None</em> to disable texturing. The texture_rectangle
property of the shape is automatically adjusted to the size of
the new texture.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that in C++, you must explicitly tell you want the texture rectangle to be reset. Here, the texture rectangle is reset by default.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a> or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Shape.texture_rectangle">
<tt class="descname">texture_rectangle</tt><a class="headerlink" href="#sf.Shape.texture_rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/get the sub-rectangle of the texture that the shape will display.</p>
<p>The texture rectangle is useful when you don&#8217;t want to display
the whole texture, but rather a part of it. By default, the
texture rectangle covers the entire texture.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Shape.fill_color">
<tt class="descname">fill_color</tt><a class="headerlink" href="#sf.Shape.fill_color" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/get the fill color of the shape.</p>
<p>This color is modulated (multiplied) with the shape&#8217;s texture if
any. It can be used to colorize the shape, or change its global
opacity. You can use <a class="reference internal" href="#sf.Color.TRANSPARENT" title="sf.Color.TRANSPARENT"><tt class="xref py py-const docutils literal"><span class="pre">sf.Color.TRANSPARENT</span></tt></a> to make the
inside of the shape transparent, and have the outline alone. By
default, the shape&#8217;s fill color is opaque white.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Color" title="sf.Color"><tt class="xref py py-class docutils literal"><span class="pre">sf.Color</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Shape.outline_color">
<tt class="descname">outline_color</tt><a class="headerlink" href="#sf.Shape.outline_color" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/get the outline color of the shape.</p>
<p>You can use <a class="reference internal" href="#sf.Color.TRANSPARENT" title="sf.Color.TRANSPARENT"><tt class="xref py py-const docutils literal"><span class="pre">sf.Color.TRANSPARENT</span></tt></a> to disable the outline.
By default, the shape&#8217;s outline color is opaque white.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Color" title="sf.Color"><tt class="xref py py-class docutils literal"><span class="pre">sf.Color</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Shape.outline_thickness">
<tt class="descname">outline_thickness</tt><a class="headerlink" href="#sf.Shape.outline_thickness" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/get the thickness of the shape&#8217;s outline.</p>
<p>This number cannot be negative. Using zero disables the outline.
By default, the outline thickness is 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Shape.local_bounds">
<tt class="descname">local_bounds</tt><a class="headerlink" href="#sf.Shape.local_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the local bounding rectangle of the entity.</p>
<p>The returned rectangle is in local coordinates, which means that
it ignores the transformations (translation, rotation, scale,
...) that are applied to the entity. In other words, this
function returns the bounds of the entity in the entity&#8217;s
coordinate system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.Shape.global_bounds">
<tt class="descname">global_bounds</tt><a class="headerlink" href="#sf.Shape.global_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the global bounding rectangle of the entity.</p>
<p>The returned rectangle is in global coordinates, which means that
it takes in account the transformations (translation, rotation,
scale, ...) that are applied to the entity. In other words, this
function returns the bounds of the sprite in the global 2D
world&#8217;s coordinate system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.CircleShape">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">CircleShape</tt><big>(</big><em>sf.Shape</em><big>)</big><a class="headerlink" href="#sf.CircleShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Specialized shape representing a circle.</p>
<p>This class inherits all the functions of <a class="reference internal" href="#sf.Transformable" title="sf.Transformable"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transformable</span></tt></a>
(position, rotation, scale, bounds, ...) as well as the functions of
<a class="reference internal" href="#sf.Shape" title="sf.Shape"><tt class="xref py py-class docutils literal"><span class="pre">sf.Shape</span></tt></a> (outline, color, texture, ...).</p>
<p>Usage example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">circle</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">CircleShape</span><span class="p">()</span>
<span class="n">circle</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mi">150</span>
<span class="n">circle</span><span class="o">.</span><span class="n">outline_color</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="o">.</span><span class="n">RED</span>
<span class="n">circle</span><span class="o">.</span><span class="n">outline_thickness</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">circle</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="c"># ...</span>
<span class="n">window</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span>
</pre></div>
</div>
<p>Since the graphics card can&#8217;t draw perfect circles, we have to fake
them with multiple triangles connected to each other. The &#8220;points
count&#8221; property of <a class="reference internal" href="#sf.CircleShape" title="sf.CircleShape"><tt class="xref py py-class docutils literal"><span class="pre">sf.CircleShape</span></tt></a> defines how many of these
triangles to use, and therefore defines the quality of the circle.</p>
<p>The number of points can also be used for another purpose; with
small numbers you can create any regular polygon shape: equilateral
triangle, square, pentagon, hexagon, ...</p>
<dl class="method">
<dt id="sf.CircleShape.CircleShape">
<tt class="descname">CircleShape</tt><big>(</big><em>[radius[, point_count]</em><big>)</big><a class="headerlink" href="#sf.CircleShape.CircleShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Default constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>radius</strong> (<em>float</em>) &#8211; Radius of the circle</li>
<li><strong>point_count</strong> (<em>integer</em>) &#8211; Number of points composing the circle</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.CircleShape.radius">
<tt class="descname">radius</tt><a class="headerlink" href="#sf.CircleShape.radius" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/get the radius of the circle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.CircleShape.point_count">
<tt class="descname">point_count</tt><a class="headerlink" href="#sf.CircleShape.point_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/get the number of points of the circle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.CircleShape.get_point">
<tt class="descname">get_point</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#sf.CircleShape.get_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a point of the shape.</p>
<p>The result is undefined if index is out of the valid range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> (<em>integer</em>) &#8211; Index of the point to get, in range [0 .. <a class="reference internal" href="#sf.CircleShape.point_count" title="sf.CircleShape.point_count"><tt class="xref py py-attr docutils literal"><span class="pre">point_count</span></tt></a> - 1]</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Index-th point of the shape</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Position" title="sf.Position"><tt class="xref py py-class docutils literal"><span class="pre">sf.Position</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.ConvexShape">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">ConvexShape</tt><big>(</big><em>sf.Shape</em><big>)</big><a class="headerlink" href="#sf.ConvexShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Specialized shape representing a convex polygon.</p>
<p>This class inherits all the functions of <a class="reference internal" href="#sf.Transformable" title="sf.Transformable"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transformable</span></tt></a>
(position, rotation, scale, bounds, ...) as well as the functions of
<a class="reference internal" href="#sf.Shape" title="sf.Shape"><tt class="xref py py-class docutils literal"><span class="pre">sf.Shape</span></tt></a> (outline, color, texture, ...).</p>
<p>It is important to keep in mind that a convex shape must always
be... convex, otherwise it may not be drawn correctly. Moreover, the
points must be defined in order; using a random order would result
in an incorrect shape.</p>
<p>Usage example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">polygon</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">ConvexShape</span><span class="p">()</span>
<span class="n">polygon</span><span class="o">.</span><span class="n">point_count</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">polygon</span><span class="o">.</span><span class="n">set_point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">polygon</span><span class="o">.</span><span class="n">set_point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">polygon</span><span class="o">.</span><span class="n">set_point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">polygon</span><span class="o">.</span><span class="n">outline_color</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="o">.</span><span class="n">RED</span>
<span class="n">polygon</span><span class="o">.</span><span class="n">outlinne_thickness</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">polygon</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="c"># ...</span>
<span class="n">window</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="sf.ConvexShape.ConvexShape">
<tt class="descname">ConvexShape</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.ConvexShape.ConvexShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Default constructor.</p>
</dd></dl>

<dl class="attribute">
<dt id="sf.ConvexShape.point_count">
<tt class="descname">point_count</tt><a class="headerlink" href="#sf.ConvexShape.point_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/get the number of points of the polygon.</p>
<p><em>count</em> must be greater than 2 to define a valid shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.ConvexShape.get_point">
<tt class="descname">get_point</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#sf.ConvexShape.get_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the position of a point.</p>
<p>The result is undefined if index is out of the valid range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> (<em>integer</em>) &#8211; Index of the point to get, in range [0 .. <a class="reference internal" href="#sf.ConvexShape.point_count" title="sf.ConvexShape.point_count"><tt class="xref py py-attr docutils literal"><span class="pre">point_count</span></tt></a> - 1]</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Position of the index-th point of the polygon</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Position" title="sf.Position"><tt class="xref py py-class docutils literal"><span class="pre">sf.Position</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.ConvexShape.set_point">
<tt class="descname">set_point</tt><big>(</big><em>index</em>, <em>point</em><big>)</big><a class="headerlink" href="#sf.ConvexShape.set_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the position of a point.</p>
<p>Don&#8217;t forget that the polygon must remain convex, and the points
need to stay ordered! <a class="reference internal" href="#sf.ConvexShape.point_count" title="sf.ConvexShape.point_count"><tt class="xref py py-attr docutils literal"><span class="pre">point_count</span></tt></a> must be called first in
order to set the total number of points. The result is undefined
if index is out of the valid range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>index</strong> (<em>integer</em>) &#8211; Index of the point to change, in range [0 .. <a class="reference internal" href="#sf.ConvexShape.point_count" title="sf.ConvexShape.point_count"><tt class="xref py py-attr docutils literal"><span class="pre">point_count</span></tt></a> - 1]</li>
<li><strong>point</strong> (<a class="reference internal" href="system.html#sf.Position" title="sf.Position"><em>sf.Position</em></a>) &#8211; New position of the point</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.RectangleShape">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">RectangleShape</tt><big>(</big><em>sf.Shape</em><big>)</big><a class="headerlink" href="#sf.RectangleShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Specialized shape representing a rectangle.</p>
<p>This class inherits all the functions of <a class="reference internal" href="#sf.Transformable" title="sf.Transformable"><tt class="xref py py-class docutils literal"><span class="pre">sf.Transformable</span></tt></a>
(position, rotation, scale, bounds, ...) as well as the functions of
<a class="reference internal" href="#sf.Shape" title="sf.Shape"><tt class="xref py py-class docutils literal"><span class="pre">sf.Shape</span></tt></a> (outline, color, texture, ...).</p>
<p>Usage example:</p>
<div class="highlight-python"><pre>rectangle = sf.RectangleShape()
rectangle.size = (100, 50)
rectangle.outline_color = sf.Color.RED
rectangle.outline_thickness = 5
rectangle.position = (10, 20-
# ...
window.draw(rectangle)</pre>
</div>
<dl class="method">
<dt id="sf.RectangleShape.RectangleShape">
<tt class="descname">RectangleShape</tt><big>(</big><span class="optional">[</span><em>size</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.RectangleShape.RectangleShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Default constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> (<a class="reference internal" href="system.html#sf.Size" title="sf.Size"><em>sf.Size</em></a>) &#8211; Size of the rectangle</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.RectangleShape.size">
<tt class="descname">size</tt><a class="headerlink" href="#sf.RectangleShape.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/get the size of the rectangle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Size" title="sf.Size"><tt class="xref py py-class docutils literal"><span class="pre">sf.Size</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.RectangleShape.point_count">
<tt class="descname">point_count</tt><a class="headerlink" href="#sf.RectangleShape.point_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of points defining the shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.RectangleShape.get_point">
<tt class="descname">get_point</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#sf.RectangleShape.get_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the position of a point.</p>
<p>The result is undefined if <em>index</em> is out of the valid range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> (<em>integer</em>) &#8211; Index of the point to get, in range [0 .. <a class="reference internal" href="#sf.RectangleShape.point_count" title="sf.RectangleShape.point_count"><tt class="xref py py-attr docutils literal"><span class="pre">point_count</span></tt></a> - 1]</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Position of the index-th point of the shape</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Position" title="sf.Position"><tt class="xref py py-class docutils literal"><span class="pre">sf.Position</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.RenderTarget">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">RenderTarget</tt><a class="headerlink" href="#sf.RenderTarget" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Base class for all render targets (window, texture, ...)</p>
<p><a class="reference internal" href="#sf.RenderTarget" title="sf.RenderTarget"><tt class="xref py py-class docutils literal"><span class="pre">sf.RenderTarget</span></tt></a> defines the common behaviour of all the
2D render targets usable in the graphics module.</p>
<p>It makes it possible to draw 2D entities like sprites, shapes,
text without using any OpenGL command directly.</p>
<p>A <a class="reference internal" href="#sf.RenderTarget" title="sf.RenderTarget"><tt class="xref py py-class docutils literal"><span class="pre">sf.RenderTarget</span></tt></a> is also able to use views
(<a class="reference internal" href="#sf.View" title="sf.View"><tt class="xref py py-class docutils literal"><span class="pre">sf.View</span></tt></a>), which are a kind of 2D cameras. With views
you can globally scroll, rotate or zoom everything that is drawn,
without having to transform every single entity. See the
documentation of <a class="reference internal" href="#sf.View" title="sf.View"><tt class="xref py py-class docutils literal"><span class="pre">sf.View</span></tt></a> for more details and sample
pieces of code about this class.</p>
<p>On top of that, render targets are still able to render direct
OpenGL stuff. It is even possible to mix together OpenGL calls
and regular SFML drawing commands. When doing so, make sure that
OpenGL states are not messed up by calling the
<a class="reference internal" href="#sf.RenderTarget.push_GL_states" title="sf.RenderTarget.push_GL_states"><tt class="xref py py-func docutils literal"><span class="pre">push_GL_states()</span></tt></a>/<a class="reference internal" href="#sf.RenderTarget.pop_GL_states" title="sf.RenderTarget.pop_GL_states"><tt class="xref py py-func docutils literal"><span class="pre">pop_GL_states()</span></tt></a> functions.</p>
</div></blockquote>
<dl class="method">
<dt id="sf.RenderTarget.RenderTarget">
<tt class="descname">RenderTarget</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.RenderTarget.RenderTarget" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is abstract.</p>
</dd></dl>

<dl class="method">
<dt id="sf.RenderTarget.clear">
<tt class="descname">clear</tt><big>(</big><span class="optional">[</span><em>color=sf.Color(0</em>, <em>0</em>, <em>0</em>, <em>255)</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.RenderTarget.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the entire target with a single color.</p>
<p>This function is usually called once every frame, to clear the
previous contents of the target.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>color</strong> (<a class="reference internal" href="#sf.Color" title="sf.Color"><em>sf.Color</em></a>) &#8211; Fill color to use to clear the render target</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.RenderTarget.view">
<tt class="descname">view</tt><a class="headerlink" href="#sf.RenderTarget.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Change or get the current active view.</p>
<p>The view is like a 2D camera, it controls which part of the 2D
scene is visible, and how it is viewed in the render-target. The
new view will affect everything that is drawn, until another view
is set. The render target keeps its own copy of the view object,
so it is not necessary to keep the original one alive after
calling this function. To restore the original view of the
target, you can set the result of <a class="reference internal" href="#sf.RenderTarget.default_view" title="sf.RenderTarget.default_view"><tt class="xref py py-attr docutils literal"><span class="pre">default_view</span></tt></a> to this
attribute.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.View" title="sf.View"><tt class="xref py py-class docutils literal"><span class="pre">sf.View</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.RenderTarget.default_view">
<tt class="descname">default_view</tt><a class="headerlink" href="#sf.RenderTarget.default_view" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the default view of the render target.</p>
<p>The default view has the initial size of the render target, and
never changes after the target has been created.</p>
</dd></dl>

<dl class="method">
<dt id="sf.RenderTarget.get_viewport">
<tt class="descname">get_viewport</tt><big>(</big><em>view</em><big>)</big><a class="headerlink" href="#sf.RenderTarget.get_viewport" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the viewport of a view, applied to this render target.</p>
<p>The viewport is defined in the view as a ratio, this function
simply applies this ratio to the current dimensions of the render
target to calculate the pixels rectangle that the viewport
actually covers in the target.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>view</strong> (<a class="reference internal" href="#sf.View" title="sf.View"><em>sf.View</em></a>) &#8211; The view for which we want to compute the viewport</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Viewport rectangle, expressed in pixels</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Rectangle" title="sf.Rectangle"><tt class="xref py py-class docutils literal"><span class="pre">sf.Rectangle</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.RenderTarget.convert_coords">
<tt class="descname">convert_coords</tt><big>(</big><em>point</em><span class="optional">[</span>, <em>view</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.RenderTarget.convert_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a point from target coordinates to view coordinates.</p>
<p>Initially, a unit of the 2D world matches a pixel of the render
target. But if you define a custom view, this assertion is not
true anymore, ie. a point located at (10, 50) in your render
target (for example a window) may map to the point (150, 75) in
your 2D world &#8211; for example if the view is translated by
(140, 25).</p>
<p>For render windows, this function is typically used to find which
point (or object) is located below the mouse cursor.</p>
<p>This version uses a custom view for calculations, see the other
overload of the function to use the current view of the render
target.</p>
</dd></dl>

<dl class="method">
<dt id="sf.RenderTarget.draw">
<tt class="descname">draw</tt><big>(</big><em>drawable</em><span class="optional">[</span>, <em>states</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.RenderTarget.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a drawable object to the render-target.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>drawable</strong> (<a class="reference internal" href="#sf.Drawable" title="sf.Drawable"><em>sf.Drawable</em></a>) &#8211; Object to draw</li>
<li><strong>states</strong> (<a class="reference internal" href="#sf.RenderStates" title="sf.RenderStates"><em>sf.RenderStates</em></a>) &#8211; Render states to use for drawing</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.RenderTarget.size">
<tt class="descname">size</tt><a class="headerlink" href="#sf.RenderTarget.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of the rendering region of the target.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="system.html#sf.Size" title="sf.Size"><tt class="xref py py-class docutils literal"><span class="pre">sf.Size</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.RenderTarget.width">
<tt class="descname">width</tt><a class="headerlink" href="#sf.RenderTarget.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the width of the rendering region of the target.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sf.RenderTarget.height">
<tt class="descname">height</tt><a class="headerlink" href="#sf.RenderTarget.height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the height of the rendering region of the target.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.RenderTarget.push_GL_states">
<tt class="descname">push_GL_states</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.RenderTarget.push_GL_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the current OpenGL render states and matrices.</p>
<p>This function can be used when you mix pySFML drawing and direct
OpenGL rendering. Combined with <a class="reference internal" href="#sf.RenderTarget.pop_GL_states" title="sf.RenderTarget.pop_GL_states"><tt class="xref py py-func docutils literal"><span class="pre">pop_GL_states()</span></tt></a>, it ensures
that:</p>
<blockquote>
<div><ul class="simple">
<li>pySFML&#8217;s internal states are not messed up by your OpenGL code</li>
<li>your OpenGL states are not modified by a call to a pySFML function</li>
</ul>
</div></blockquote>
<p>More specifically, it must be used around code that calls <a class="reference internal" href="#sf.RenderTarget.draw" title="sf.RenderTarget.draw"><tt class="xref py py-func docutils literal"><span class="pre">draw()</span></tt></a> functions. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># OpenGL code here...</span>
<span class="n">window</span><span class="o">.</span><span class="n">push_GL_state</span><span class="p">()</span>
<span class="n">window</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">window</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">window</span><span class="o">.</span><span class="n">pop_GL_states</span><span class="p">()</span>
<span class="c"># OpenGL code here...</span>
</pre></div>
</div>
<p>Note that this function is quite expensive: it saves all the
possible OpenGL states and matrices, even the ones you don&#8217;t care
about. Therefore it should be used wisely. It is provided for
convenience, but the best results will be achieved if you handle
OpenGL states yourself (because you know which states have really
changed, and need to be saved and restored). Take a look at the
:func:<a href="#id3"><span class="problematic" id="id4">`</span></a>reset_GL_states function if you do so.</p>
</dd></dl>

<dl class="method">
<dt id="sf.RenderTarget.pop_GL_states">
<tt class="descname">pop_GL_states</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.RenderTarget.pop_GL_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore the previously saved OpenGL render states and matrices.</p>
<p>See the description of :func:<a href="#id5"><span class="problematic" id="id6">`</span></a>push_GL_states to get a detailed
description of these functions.</p>
</dd></dl>

<dl class="method">
<dt id="sf.RenderTarget.reset_GL_states">
<tt class="descname">reset_GL_states</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.RenderTarget.reset_GL_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the internal OpenGL states so that the target is ready for
drawing.</p>
<p>This function can be used when you mix pySFML drawing and direct
OpenGL rendering, if you choose not to use
<a class="reference internal" href="#sf.RenderTarget.push_GL_states" title="sf.RenderTarget.push_GL_states"><tt class="xref py py-func docutils literal"><span class="pre">push_GL_states()</span></tt></a>/<a class="reference internal" href="#sf.RenderTarget.pop_GL_states" title="sf.RenderTarget.pop_GL_states"><tt class="xref py py-func docutils literal"><span class="pre">pop_GL_states()</span></tt></a>. It makes sure that
all OpenGL states needed by pySFML are set, so that subsequent
<a class="reference internal" href="#sf.RenderTarget.draw" title="sf.RenderTarget.draw"><tt class="xref py py-func docutils literal"><span class="pre">draw()</span></tt></a> calls will work as expected.</p>
<blockquote>
<div># OpenGL code here...
glPushAttrib(...)
window.reset_GL_states()
window.draw(...)
window.draw(...)
glPopAttrib(...)
# OpenGL code here...</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.RenderWindow">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">RenderWindow</tt><big>(</big><em>sf.Window</em>, <em>sf.RenderTarget</em><big>)</big><a class="headerlink" href="#sf.RenderWindow" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="window.html#sf.Window" title="sf.Window"><tt class="xref py py-class docutils literal"><span class="pre">Window</span></tt></a> that can serve as a target for 2D drawing.</p>
<p><a class="reference internal" href="#sf.RenderWindow" title="sf.RenderWindow"><tt class="xref py py-class docutils literal"><span class="pre">sf.RenderWindow</span></tt></a> is the main class of the graphics module.</p>
<p>It defines an OS window that can be painted using the other classes
of the graphics module.</p>
<p><a class="reference internal" href="#sf.RenderWindow" title="sf.RenderWindow"><tt class="xref py py-class docutils literal"><span class="pre">sf.RenderWindow</span></tt></a> is derived from <a class="reference internal" href="window.html#sf.Window" title="sf.Window"><tt class="xref py py-class docutils literal"><span class="pre">sf.Window</span></tt></a>, thus it
inherits all its features: events, window management, OpenGL
rendering, etc. See the documentation of <a class="reference internal" href="window.html#sf.Window" title="sf.Window"><tt class="xref py py-class docutils literal"><span class="pre">sf.Window</span></tt></a> for a
more complete description of all these features, as well as code
examples.</p>
<p>On top of that, <a class="reference internal" href="#sf.RenderWindow" title="sf.RenderWindow"><tt class="xref py py-class docutils literal"><span class="pre">sf.RenderWindow</span></tt></a> adds more features related
to 2D drawing with the graphics module (see its base class
<a class="reference internal" href="#sf.RenderTarget" title="sf.RenderTarget"><tt class="xref py py-class docutils literal"><span class="pre">sf.RenderTarget</span></tt></a> for more details). Here is a typical
rendering and event loop with a <a class="reference internal" href="#sf.RenderWindow" title="sf.RenderWindow"><tt class="xref py py-class docutils literal"><span class="pre">sf.RenderWindow</span></tt></a></p>
<dl class="method">
<dt id="sf.RenderWindow.RenderWindow">
<tt class="descname">RenderWindow</tt><big>(</big><em>mode</em>, <em>title</em><span class="optional">[</span>, <em>style</em><span class="optional">[</span>, <em>settings</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.RenderWindow.RenderWindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a new window.</p>
<p>This constructor creates the window with the size and pixel depth
defined in mode. An optional style can be passed to customize the
look and behaviour of the window (borders, title bar, resizable,
closable, ...).</p>
<p>The fourth parameter is an optional structure specifying advanced
OpenGL context settings such as antialiasing, depth-buffer bits,
etc. You shouldn&#8217;t care about these parameters for a regular
usage of the graphics module.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mode</strong> (<a class="reference internal" href="window.html#sf.VideoMode" title="sf.VideoMode"><em>sf.VideoMode</em></a>) &#8211; Video mode to use (defines the width, height and depth of the rendering area of the window)</li>
<li><strong>title</strong> (<em>string</em>) &#8211; Title of the window</li>
<li><strong>style</strong> (<a class="reference internal" href="window.html#sf.Style" title="sf.Style"><tt class="xref py py-class docutils literal"><span class="pre">sf.Style</span></tt></a>&#8216;s constant) &#8211; Window style</li>
<li><strong>settings</strong> (<a class="reference internal" href="window.html#sf.ContextSettings" title="sf.ContextSettings"><em>sf.ContextSettings</em></a>) &#8211; Additional settings for the underlying OpenGL context</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sf.RenderWindow.capture">
<tt class="descname">capture</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.RenderWindow.capture" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the current contents of the window to an image.</p>
<p>This is a slow operation, whose main purpose is to make
screenshots of the application. If you want to update an image
with the contents of the window and then use it for drawing, you
should rather use a <a class="reference internal" href="#sf.Texture" title="sf.Texture"><tt class="xref py py-class docutils literal"><span class="pre">sf.Texture</span></tt></a> and its
<tt class="xref py py-func docutils literal"><span class="pre">update_window()</span></tt> function. You can also draw things directly
to a texture with the <tt class="xref py py-class docutils literal"><span class="pre">sf.RenderTexture</span></tt> class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Image containing the captured contents</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#sf.Image" title="sf.Image"><tt class="xref py py-class docutils literal"><span class="pre">sf.Image</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">RenderWindow</tt><big>(</big><em>sf.RenderTarget</em><big>)</big></dt>
<dd><p>Target for off-screen 2D rendering into an texture.</p>
<p><tt class="xref py py-class docutils literal"><span class="pre">sf.RenderTexture</span></tt> is the little brother of
<a class="reference internal" href="#sf.RenderWindow" title="sf.RenderWindow"><tt class="xref py py-class docutils literal"><span class="pre">sf.RenderWindow</span></tt></a>.</p>
<p>It implements the same 2D drawing and OpenGL-related functions (see
their base class <a class="reference internal" href="#sf.RenderTarget" title="sf.RenderTarget"><tt class="xref py py-class docutils literal"><span class="pre">sf.RenderTarget</span></tt></a> for more details), the
difference is that the result is stored in an off-screen texture
rather than being show in a window.</p>
<p>Rendering to a texture can be useful in a variety of situations:</p>
<blockquote>
<div><ul class="simple">
<li>precomputing a complex static texture (like a level&#8217;s background from multiple tiles)</li>
<li>applying post-effects to the whole scene with shaders</li>
<li>creating a sprite from a 3D object rendered with OpenGL</li>
<li>etc.</li>
</ul>
</div></blockquote>
<p>Usage example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># create a new render-window</span>
<span class="n">window</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">RenderWindow</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">VideoMode</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="s">&quot;pySFML - RenderWindow&quot;</span><span class="p">)</span>

<span class="c"># create a new render-texture</span>
<span class="n">texture</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">RenderTexture</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>

<span class="c"># the main loop</span>
<span class="k">while</span> <span class="n">window</span><span class="o">.</span><span class="n">opened</span><span class="p">:</span>

   <span class="c"># ...</span>

   <span class="c"># clear the whole texture with red color</span>
   <span class="n">texture</span><span class="o">.</span><span class="n">clear</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">Color</span><span class="o">.</span><span class="n">RED</span><span class="p">)</span>

   <span class="c"># draw stuff to the texture</span>
   <span class="n">texture</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
   <span class="n">texture</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
   <span class="n">texture</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

   <span class="c"># we&#39;re done drawing to the texture</span>
   <span class="n">texture</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>

   <span class="c"># now we start rendering to the window, clear it first</span>
   <span class="n">window</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

   <span class="c"># draw the texture</span>
   <span class="n">sprite</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Sprite</span><span class="p">(</span><span class="n">texture</span><span class="o">.</span><span class="n">texture</span><span class="p">)</span>
   <span class="n">window</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>

   <span class="c"># end the current frame and display its content on screen</span>
   <span class="n">window</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="sf.RenderWindow.RenderTexture">
<tt class="descname">RenderTexture</tt><big>(</big><em>width</em>, <em>height</em><span class="optional">[</span>, <em>depth_buffer=False</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sf.RenderWindow.RenderTexture" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the render-texture.</p>
<p>The last parameter, <em>depth_buffer</em>, is useful if you want to use
the render-texture for 3D OpenGL rendering that requires a
depth-buffer. Otherwise it is unnecessary, and you should leave
this parameter to false (which is its default value).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>width</strong> (<em>integer</em>) &#8211; Width of the render-texture</li>
<li><strong>height</strong> (<em>integer</em>) &#8211; Height of the render-texture</li>
<li><strong>depth_buffer</strong> (<em>integer</em>) &#8211; Do you want this render-texture to have a depth buffer?</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">sf.RenderTexture</span></tt></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sf.View">
<em class="property">class </em><tt class="descclassname">sf.</tt><tt class="descname">View</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.View" title="Permalink to this definition">¶</a></dt>
<dd><p>2D camera that defines what region is shown on screen</p>
<p>sf.View defines a camera in the 2D scene.</p>
<p>This is a very powerful concept: you can scroll, rotate or zoom the entire scene without altering the way that your drawable objects are drawn.</p>
<p>A view is composed of a source rectangle, which defines what part of the 2D scene is shown, and a target viewport, which defines where the contents of the source rectangle will be displayed on the render target (window or texture).</p>
<p>The viewport allows to map the scene to a custom part of the render target, and can be used for split-screen or for displaying a minimap, for example. If the source rectangle has not the same size as the viewport, its contents will be stretched to fit in.</p>
<p>To apply a view, you have to assign it to the render target. Then, every objects drawn in this render target will be affected by the view until you use another view.</p>
<p>Usage example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">window</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">RenderWindow</span><span class="p">()</span>
<span class="n">view</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">View</span><span class="p">()</span>

<span class="c"># initialize the view to a rectangle located at (100, 100) and with a size of 400x200</span>
<span class="n">view</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">200</span><span class="p">))</span>

<span class="c"># rotate it by 45 degrees</span>
<span class="n">view</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>

<span class="c"># set its target viewport to be half of the window and apply it</span>
<span class="n">view</span><span class="o">.</span><span class="n">viewport</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c"># or a tuple (0, 0, 0.5, 1)</span>
<span class="n">window</span><span class="o">.</span><span class="n">view</span> <span class="o">=</span> <span class="n">view</span>

<span class="c"># render stuff</span>
<span class="n">window</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">some_sprite</span><span class="p">);</span>

<span class="c"># set the default view back</span>
<span class="n">window</span><span class="o">.</span><span class="n">view</span> <span class="o">=</span> <span class="n">window</span><span class="o">.</span><span class="n">default_view</span>

<span class="c"># render stuff not affected by the view</span>
<span class="n">window</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">some_text</span><span class="p">);</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="sf.View.center">
<tt class="descname">center</tt><a class="headerlink" href="#sf.View.center" title="Permalink to this definition">¶</a></dt>
<dd><p>The center of the view.</p>
</dd></dl>

<dl class="attribute">
<dt id="sf.View.size">
<tt class="descname">size</tt><a class="headerlink" href="#sf.View.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the view.</p>
</dd></dl>

<dl class="attribute">
<dt id="sf.View.rotation">
<tt class="descname">rotation</tt><a class="headerlink" href="#sf.View.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>The orientation of the view.</p>
</dd></dl>

<dl class="attribute">
<dt id="sf.View.viewport">
<tt class="descname">viewport</tt><a class="headerlink" href="#sf.View.viewport" title="Permalink to this definition">¶</a></dt>
<dd><p>The target viewport.</p>
<p>The viewport is the rectangle into which the contents of the view are displayed, expressed as a factor (between 0 and 1) of the size of the RenderTarget to which the view is applied. For example, a view which takes the left side of the target would be defined with view.viewport = (0, 0, 0.5, 1). By default, a view has a viewport which covers the entire target.</p>
</dd></dl>

<dl class="method">
<dt id="sf.View.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#sf.View.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the view to the given rectangle.</p>
<p>Note that this function resets the rotation angle to 0</p>
</dd></dl>

<dl class="method">
<dt id="sf.View.move">
<tt class="descname">move</tt><big>(</big><em>offset</em><big>)</big><a class="headerlink" href="#sf.View.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move the view relatively to its current position.</p>
</dd></dl>

<dl class="method">
<dt id="sf.View.rotate">
<tt class="descname">rotate</tt><big>(</big><em>(float angle</em><big>)</big><a class="headerlink" href="#sf.View.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the view relatively to its current orientation.</p>
</dd></dl>

<dl class="method">
<dt id="sf.View.zoom">
<tt class="descname">zoom</tt><big>(</big><em>float factor</em><big>)</big><a class="headerlink" href="#sf.View.zoom" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize the view rectangle relatively to its current size.</p>
<p>Resizing the view simulates a zoom, as the zone displayed on screen grows or shrinks. factor is a multiplier:</p>
<blockquote>
<div>1 keeps the size unchanged
&gt; 1 makes the view bigger (objects appear smaller)
&lt; 1 makes the view smaller (objects appear bigger)</div></blockquote>
</dd></dl>

<dl class="classmethod">
<dt id="sf.View.from_center_and_size">
<em class="property">classmethod </em><tt class="descname">from_center_and_size</tt><big>(</big><em>center</em>, <em>size</em><big>)</big><a class="headerlink" href="#sf.View.from_center_and_size" title="Permalink to this definition">¶</a></dt>
<dd><p><em>center</em> and <em>size</em> can be either tuples or <tt class="xref py py-class docutils literal"><span class="pre">Vector2f</span></tt>.</p>
</dd></dl>

<dl class="classmethod">
<dt id="sf.View.from_rect">
<em class="property">classmethod </em><tt class="descname">from_rect</tt><big>(</big><em>rect</em><big>)</big><a class="headerlink" href="#sf.View.from_rect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="sf.View.width">
<tt class="descname">width</tt><a class="headerlink" href="#sf.View.width" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="sf.View.height">
<tt class="descname">height</tt><a class="headerlink" href="#sf.View.height" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/sfml2-logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="window.html"
                        title="previous chapter">Window</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="audio.html"
                        title="next chapter">Audio</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/documentation/graphics.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="audio.html" title="Audio"
             >next</a> |</li>
        <li class="right" >
          <a href="window.html" title="Window"
             >previous</a> |</li>
        <li><a href="../index.html">pySFML2 1.0 documentation</a> &raquo;</li>
          <li><a href="../documentation.html" >Documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Jonathan De Wachter.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>